var zt=Object.defineProperty;var $t=(i,t,e)=>t in i?zt(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var h=(i,t,e)=>($t(i,typeof t!="symbol"?t+"":t,e),e);import{P as mt,g as Wt}from"./generate-scene-oCWeBa7x.js";import{d as Yt,r as B,o as Gt,a as Xt,c as N,b as w,t as y,F as yt,e as pt,u as Ht,f as P,n as jt,p as Kt,g as Zt,_ as qt}from"./index-DiJUbm4W.js";const Dt=20,ht=32-Dt,rt=Math.pow(2,Dt),bt=Math.pow(2,ht);function F(i,t=0){return lt(Atomics.load(i,t))}function Qt(i,t=0){return Atomics.load(i,t)}function gt(i,t=0,e,s){Atomics.store(i,t,Ft(e,s))}function Bt(i,t=0,e){Atomics.store(i,t,e)}function Jt(i,t,e,s){return Atomics.compareExchange(i,t,s,e)===s}function lt(i){return{bufferPosition:i&4095,bufferByteOffset:i>>>ht}}function Ft(i,t){return i+(t<<ht)}class b{get bufferByteOffset(){return this.data.byteOffset}get pointer(){return Ft(this.bufferPosition,this.bufferByteOffset)}constructor(t,e){this.memory=t,"buffer"in e?(this.data=e.data,this.buffer=e.buffer,this.bufferPosition=this.memory.buffers.indexOf(e.buffer)):(this.bufferPosition=e.bufferPosition,this.buffer=t.buffers[e.bufferPosition],this.data=new Uint32Array(this.buffer.buf,e.bufferByteOffset))}getArray(t,e,s){return new t(this.data.buffer,this.data.byteOffset+e*t.BYTES_PER_ELEMENT,s)}getArrayMemory(t,e){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset+t*this.data.BYTES_PER_ELEMENT}}free(){this.buffer.free(this.data.byteOffset)}getSharedMemory(){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset}}}const ot=0,Y=1;function wt(i,t=0){for(;Atomics.compareExchange(i,t,ot,Y)!==ot;)"WorkerGlobalScope"in self&&Atomics.wait(i,t,Y)}function C(i,t=0){Atomics.compareExchange(i,t,Y,ot)!==Y&&console.warn("We are unlocking when it was not locked!"),Atomics.notify(i,t)}const Vt={5120:"i8",5121:"u8",5122:"i16",5123:"u16",5124:"i32",5125:"u32",5126:"f32"},te={f32:Float32Array,f64:Float64Array},ee={i8:Int8Array,i16:Int16Array,i32:Int32Array},se={u8:Uint8Array,u8c:Uint8ClampedArray,u16:Uint16Array,u32:Uint32Array},ie={i64:BigInt64Array,u64:BigUint64Array},re={...te,...ee,...se},oe=i=>{const t=Vt[i];return t!==void 0?t:i};function ne(i,...t){const e=ie[i];return new(e||re[oe(i)])(...t)}const At=0,kt=1,Et=2,St=3,_t=4,_=5,Mt=6,Q=1,J=2,Tt=8*4,V=0,tt=1,A=2*4;class et{constructor(t={}){if(this.buf=t.buf?t.buf:new ArrayBuffer(t.size||4096),this.start=t.start!=null?$(Math.max(t.start,0),4):0,this.u8=new Uint8Array(this.buf),this.u32=new Uint32Array(this.buf),this.state=new Uint32Array(this.buf,this.start,Tt/4),this.lock=new Int32Array(this.buf,this.start+this.state.byteLength-4,1),!t.skipInitialization){const e=t.align||8;if(e<8)throw new Error(`invalid alignment: ${e}, must be a pow2 and >= 8`);const s=this.initialTop(e),r=t.end!=null?Math.min(t.end,this.buf.byteLength):this.buf.byteLength;if(s>=r)throw new Error(`insufficient address range (0x${this.start.toString(16)} - 0x${r.toString(16)})`);this.align=e,this.doCompact=t.compact!==!1,this.doSplit=t.split!==!1,this.minSplit=t.minSplit||16,this.end=r,this.top=s,this._free=0,this._used=0}}stats(){const t=s=>{let r=0,o=0;for(;s;)if(r++,o+=this.blockSize(s),s=this.blockNext(s),s>this.end){console.error(`Trying to get stats for block past end of buffer: ${s} > ${this.end}`);break}return{count:r,size:o}},e=t(this._free);return{free:e,used:t(this._used),top:this.top,available:this.end-this.top+e.size,total:this.buf.byteLength}}callocAs(t,e,s=0){const r=this.mallocAs(t,e);return r&&r.fill(s),r}mallocAs(t,e){const s=this.malloc(e*ae[t]);return s?ne(t,this.buf,s,e):void 0}calloc(t,e=0){const s=this.malloc(t);return s&&this.u8.fill(e,s,s+t),s}malloc(t){if(t<=0)return 0;wt(this.lock);const e=$(t+A,this.align),s=this.end;let r=this.top,o=this._free,n=0;for(;o;){const u=this.blockSize(o),f=o+u>=r;if(f||u>=e){let d=this.mallocTop(o,n,u,e,f);return C(this.lock),d}n=o,o=this.blockNext(o)}if(o=r,r=o+e,r<=s){this.initBlock(o,e,this._used),this._used=o,this.top=r;let u=I(o);return C(this.lock),u}return C(this.lock),0}mallocTop(t,e,s,r,o){if(o&&t+r>this.end)return 0;if(e?this.unlinkBlock(e,t):this._free=this.blockNext(t),this.setBlockNext(t,this._used),this._used=t,o)this.top=t+this.setBlockSize(t,r);else if(this.doSplit){const n=s-r;n>=this.minSplit&&this.splitBlock(t,r,n)}return I(t)}realloc(t,e){if(e<=0)return 0;const s=z(t);let r=0,o=this._used,n=0;for(;o;){if(o===s){[r,n]=this.reallocBlock(o,e);break}o=this.blockNext(o)}return r&&r!==s&&this.u8.copyWithin(I(r),I(s),n),I(r)}reallocBlock(t,e){const s=this.blockSize(t),r=t+s,o=r>=this.top,n=$(e+A,this.align);if(n<=s){if(this.doSplit){const u=s-n;u>=this.minSplit?this.splitBlock(t,n,u):o&&(this.top=t+n)}else o&&(this.top=t+n);return[t,r]}return o&&t+n<this.end?(this.top=t+this.setBlockSize(t,n),[t,r]):(this.free(t),[z(this.malloc(e)),r])}reallocArray(t,e){if(t.buffer!==this.buf)return;const s=this.realloc(t.byteOffset,e*t.BYTES_PER_ELEMENT);return s?new t.constructor(this.buf,s,e):void 0}bytesFor(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return;e=t.byteOffset}else e=t;e=z(e);let s=this._used;for(;s;){if(s===e)return this.blockSize(e);s=this.blockNext(s)}}lengthOf(t){let e=this.bytesFor(t);if(e)return e/this.u32.BYTES_PER_ELEMENT}free(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return!1;e=t.byteOffset}else e=t;wt(this.lock),e=z(e);let s=this._used,r=0;for(;s;){if(s===e)return r?this.unlinkBlock(r,s):this._used=this.blockNext(s),this.insert(s),this.doCompact&&this.compact(),C(this.lock),!0;r=s,s=this.blockNext(s)}return C(this.lock),!1}freeAll(){this._free=0,this._used=0,this.top=this.initialTop()}release(){return delete this.u8,delete this.u32,delete this.state,delete this.buf,!0}get align(){return this.state[_t]}set align(t){this.state[_t]=t}get end(){return this.state[St]}set end(t){this.state[St]=t}get top(){return Atomics.load(this.state,Et)}set top(t){Atomics.store(this.state,Et,t)}get _free(){return Atomics.load(this.state,At)}set _free(t){Atomics.store(this.state,At,t)}get _used(){return Atomics.load(this.state,kt)}set _used(t){Atomics.store(this.state,kt,t)}get doCompact(){return!!(this.state[_]&Q)}set doCompact(t){t?this.state[_]|=1<<Q-1:this.state[_]&=~Q}get doSplit(){return!!(this.state[_]&J)}set doSplit(t){t?this.state[_]|=1<<J-1:this.state[_]&=~J}get minSplit(){return this.state[Mt]}set minSplit(t){if(t<=A)throw new Error(`illegal min split threshold: ${t}, require at least ${A+1}`);this.state[Mt]=t}blockSize(t){return Atomics.load(this.u32,(t>>2)+V)}setBlockSize(t,e){return Atomics.store(this.u32,(t>>2)+V,e),e}blockNext(t){return Atomics.load(this.u32,(t>>2)+tt)}setBlockNext(t,e){Atomics.store(this.u32,(t>>2)+tt,e)}initBlock(t,e,s){const r=t>>>2;return Atomics.store(this.u32,r+V,e),Atomics.store(this.u32,r+tt,s),t}unlinkBlock(t,e){this.setBlockNext(t,this.blockNext(e))}splitBlock(t,e,s){this.insert(this.initBlock(t+this.setBlockSize(t,e),s,0)),this.doCompact&&this.compact()}initialTop(t=this.align){return $(this.start+Tt+A,t)-A}compact(){let t=this._free,e=0,s=0,r,o=!1;for(;t;){for(r=t,s=this.blockNext(t);s&&r+this.blockSize(r)===s;)r=s,s=this.blockNext(s);if(r!==t){const n=r-t+this.blockSize(r);this.setBlockSize(t,n);const u=this.blockNext(r);let f=this.blockNext(t);for(;f&&f!==u;){const d=this.blockNext(f);this.setBlockNext(f,0),f=d}this.setBlockNext(t,u),o=!0}t+this.blockSize(t)>=this.top&&(this.top=t,e?this.unlinkBlock(e,t):this._free=this.blockNext(t)),e=t,t=this.blockNext(t)}return o}insert(t){let e=this._free,s=0;for(;e&&!(t<=e);)s=e,e=this.blockNext(e);s?this.setBlockNext(s,t):this._free=t,this.setBlockNext(t,e)}}const I=i=>i>0?i+A:0,z=i=>i>0?i-A:0,$=(i,t)=>(t--,i+t&~t),ae={u8:1,u8c:1,i8:1,u16:2,i16:2,u32:4,i32:4,i64:8,u64:8,f32:4,f64:8},he=["B","kB","MB","GB","TB","PB","EB","ZB","YB"],le=["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],fe=["b","kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],ue=["b","kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],Ot=(i,t,e)=>{let s=i;return typeof t=="string"||Array.isArray(t)?s=i.toLocaleString(t,e):(t===!0||e!==void 0)&&(s=i.toLocaleString(void 0,e)),s};function ce(i,t){if(!Number.isFinite(i))throw new TypeError(`Expected a finite number, got ${typeof i}: ${i}`);t={bits:!1,binary:!1,space:!0,...t};const e=t.bits?t.binary?ue:fe:t.binary?le:he,s=t.space?" ":"";if(t.signed&&i===0)return` 0${s}${e[0]}`;const r=i<0,o=r?"-":t.signed?"+":"";r&&(i=-i);let n;if(t.minimumFractionDigits!==void 0&&(n={minimumFractionDigits:t.minimumFractionDigits}),t.maximumFractionDigits!==void 0&&(n={maximumFractionDigits:t.maximumFractionDigits,...n}),i<1){const g=Ot(i,t.locale,n);return o+g+s+e[0]}const u=Math.min(Math.floor(t.binary?Math.log(i)/Math.log(1024):Math.log10(i)/3),e.length-1);i/=(t.binary?1024:1e3)**u,n||(i=i.toPrecision(3));const f=Ot(Number(i),t.locale,n),d=e[u];return o+f+s+d}const de=8192;class Nt{constructor(t){if(this.onGrowBufferHandlers=[],t&&"buffers"in t)this.buffers=t.buffers.map(e=>new et({buf:e,skipInitialization:!0})),this.memory=new b(this,{bufferPosition:0,bufferByteOffset:40}),this.isClone=!0;else{const e=(t==null?void 0:t.bufferSize)??de;if(e>rt)throw new Error(`Buffer size ${e} is greater than max ${rt} that we can reference with pointers`);let s=this.createBuffer(e);this.buffers=[s];const r=s.callocAs("u32",1);if(r)this.memory=new b(this,{bufferPosition:0,bufferByteOffset:r.byteOffset});else throw new Error("Failed to initialize first byte from buffer");this.memory.data[0]=e,this.isClone=!1;for(let o=1;o<((t==null?void 0:t.initialBuffers)??1);o++)this.buffers.push(this.createBuffer(e))}}get bufferSize(){return this.memory.data[0]}addSharedBuffer(t){this.buffers.push(new et({buf:t,skipInitialization:!0}))}createBuffer(t){if(this.isClone)throw new Error("Creating new buffer from worker threads not currently supported");return new et({buf:new SharedArrayBuffer(t??this.bufferSize)})}allocUI32(t){for(let r=0;r<this.buffers.length;r++){const o=this.buffers[r],n=o.callocAs("u32",t);if(n)return new b(this,{data:n,buffer:o})}if(this.buffers.length>=bt)throw new Error(`Can't initialize a new buffer since it would have a position greater than the max of ${bt}`);const e=this.createBuffer();this.buffers.push(e),this.onGrowBufferHandlers.forEach(r=>r(e.buf));const s=e.callocAs("u32",t);if(s)return new b(this,{data:s,buffer:e});throw new Error(`Unable to allocate ${t} numbers even after adding a new buffer`)}get currentUsed(){return this.totalAllocated-this.buffers.reduce((t,e)=>t+e.stats().available,0)}get totalAllocated(){return this.buffers[0].buf.byteLength*this.buffers.length}prettyMemory(){return`${Pt(this.currentUsed)} / ${Pt(this.totalAllocated)}`}getSharedMemory(){return{buffers:this.buffers.map(t=>t.buf)}}}function Pt(i){return ce(i,{binary:!0,minimumFractionDigits:1,maximumFractionDigits:1})}const Ct=4,It=1,x=2,ft=class ft{get length(){return Atomics.load(this.firstBlock.data,x)}get type(){return Atomics.load(this.uint16Array,0)}set type(t){Atomics.store(this.uint16Array,0,t)}get dataLength(){return Math.max(1,Atomics.load(this.uint16Array,1))}set dataLength(t){Atomics.store(this.uint16Array,1,t)}constructor(t,e){if(this.memory=t,e&&"firstBlock"in e)this.firstBlock=new b(t,e.firstBlock),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(x+1)*Uint32Array.BYTES_PER_ELEMENT,2);else{e&&e.initWithBlock?(this.firstBlock=new b(t,e.initWithBlock),console.log(`init block at ${this.firstBlock.data.byteOffset}`)):this.firstBlock=t.allocUI32(Ct),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(x+1)*Uint32Array.BYTES_PER_ELEMENT,2);const s=(e==null?void 0:e.type)??Uint32Array;s===Uint32Array?this.type=0:s===Int32Array?this.type=1:s===Float32Array&&(this.type=2),this.dataLength=(e==null?void 0:e.dataLength)??1}}insert(t){typeof t=="number"&&(t=[t]);let e=this.dataLength;if(t.length>e)throw new Error(`Can't insert ${t.length} array into shared list of ${e} dataLength`);let s=this.memory.allocUI32(It+e),r=this.getDataBlock(s.data),o=s.pointer;for(let f=0;f<t.length;f++)r instanceof Int32Array||r instanceof Uint32Array?Atomics.store(r,f,t[f]):r[f]=t[f];let n,u=!1;for(;!u;)n=Qt(this.firstBlock.data,1),u=Jt(this.firstBlock.data,1,o,n);if(n){let{bufferPosition:f,bufferByteOffset:d}=lt(n),g=new Uint32Array(this.memory.buffers[f].buf,d,1);Bt(g,0,o)}else Bt(this.firstBlock.data,0,o),console.log(`insert first block ${o} at ${this.firstBlock.data.byteOffset}`);Atomics.add(this.firstBlock.data,x,1)}deleteMatch(t){for(let{data:e,index:s,deleteCurrent:r}of this)if(t(e,s))return r(),!0;return!1}deleteIndex(t){return t>=this.length||t<0?!1:this.deleteMatch((e,s)=>s===t)}deleteValue(t){return typeof t=="number"?this.deleteMatch(e=>e[0]===t):this.deleteMatch(e=>{if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0})}*[Symbol.iterator](){let t=0,{bufferPosition:e,bufferByteOffset:s}=F(this.firstBlock.data,0);console.log(`checking first block: ${s} at ${this.firstBlock.data.byteOffset}`);let r=this.firstBlock.data,o=0,n=0;for(;s;){let u=this.memory.buffers[e],f=new Uint32Array(u.buf,s,2),d=this.getDataBlock(f),g=e,S=s;({bufferPosition:e,bufferByteOffset:s}=F(f,0));let L=!0;yield{data:d,index:t,deleteCurrent:()=>{gt(r,0,e,s),s||gt(this.firstBlock.data,1,o,n),u.free(f.byteOffset),Atomics.sub(this.firstBlock.data,x,1),L=!1}},L&&(r=f,o=g,n=S,t++)}}forEach(t){for(let e of this)t(e.data)}getSharedMemory(){return{firstBlock:this.firstBlock.getSharedMemory()}}getDataBlock(t){const e=t.byteOffset+It*t.BYTES_PER_ELEMENT;switch(this.type){case 1:return new Int32Array(t.buffer,e,this.dataLength);case 0:return new Uint32Array(t.buffer,e,this.dataLength);case 2:return new Float32Array(t.buffer,e,this.dataLength);default:throw new Error(`Unknown data block type ${this.type}`)}}free(){let{bufferPosition:t,bufferByteOffset:e}=F(this.firstBlock.data,0);for(;e;){let s=new b(this.memory,{bufferPosition:t,bufferByteOffset:e});({bufferPosition:t,bufferByteOffset:e}=F(s.data,0)),s.free()}this.firstBlock.free()}};ft.ALLOCATE_COUNT=Ct;let T=ft;const me=new ArrayBuffer(8);new BigUint64Array(me);const ye=0,st=1,xt=2,X=class X{constructor(t,e){h(this,"world");h(this,"memory");h(this,"takenMemoryBytes",0);h(this,"_id");h(this,"positionMemory");h(this,"key","boid");h(this,"shieldMemory");h(this,"getSprite");this.world=t,"size"in e?(this.memory=t.heap.allocUI32(e.size+X.ALLOCATE_COUNT),this.memory.data[st]=t.getId(),this.memory.data[ye]=e.type):e instanceof b?this.memory=e:this.memory=new b(t.heap,e),this._id=this.memory.data[st],this.takenMemoryBytes+=3*this.memory.data.BYTES_PER_ELEMENT,this.positionMemory=this.getArrayFromMemory(Float32Array,5),this.shieldMemory=this.getArrayFromMemory(Float32Array,5)}get id(){return this._id}get dead(){return this._id!==this.memory.data[st]||!!this.memory.data[xt]}set dead(t){this.memory.data[xt]=t?1:0}get x(){return this.positionMemory[0]}set x(t){this.positionMemory[0]=t}get y(){return this.positionMemory[1]}set y(t){this.positionMemory[1]=t}get width(){return this.positionMemory[2]}set width(t){this.positionMemory[2]=t}get height(){return this.positionMemory[3]}set height(t){this.positionMemory[3]=t}get angle(){return this.positionMemory[4]}set angle(t){this.positionMemory[4]=t}get shields(){return this.shieldMemory[0]}set shields(t){this.shieldMemory[0]=t}get maxShields(){return this.shieldMemory[1]}set maxShields(t){this.shieldMemory[1]=t}get timeToRegenerateShields(){return this.shieldMemory[2]}set timeToRegenerateShields(t){this.shieldMemory[2]=t}get timeSinceShieldRegeneration(){return this.shieldMemory[3]}set timeSinceShieldRegeneration(t){this.shieldMemory[3]=t}get timeSinceTakenDamage(){return this.shieldMemory[4]}set timeSinceTakenDamage(t){this.shieldMemory[4]=t}load(t){Object.keys(t).forEach(e=>{this[e]=t[e]})}die(){this.dead=!0,this.world.removeEntity(this),this.memory.free()}canTakeDamage(){return this.timeSinceTakenDamage>=.2&&!this.dead}takeDamage(t){this.canTakeDamage()&&(this.shields-=t,this.timeSinceTakenDamage=0,this.shields<0&&this.die())}getArrayFromMemory(t,e){let s=this.getAllocatedFromMemory(e);return new t(this.memory.data.buffer,s.bufferByteOffset,e)}getAllocatedFromMemory(t){let e=this.takenMemoryBytes;return this.takenMemoryBytes+=t*4,{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+e}}get pointer(){return this.memory.pointer}};h(X,"ALLOCATE_COUNT",13);let G=X;var v=(i=>(i[i.ship=1]="ship",i[i.station=2]="station",i))(v||{});class k{constructor(t,e){h(this,"world");h(this,"list");h(this,"entityCache",new Map);this.world=t,e?this.list=new T(t.heap,e):this.list=new T(t.heap)}get length(){return this.list.length}insert(t){this.list.insert(t.pointer),this.entityCache.set(t.pointer,t)}delete(t){return this.entityCache.delete(t.pointer),this.list.deleteValue(t.pointer)}*[Symbol.iterator](){let t=this.list[Symbol.iterator]();for(let{data:e,deleteCurrent:s}of t){let r=Atomics.load(e,0),o=this.world.getEntityByPointer(r);o&&(yield{entity:o,deleteCurrent:s})}}forEach(t,e){for(let{entity:s}of this)(!e||e(s))&&t(s)}find(t){for(let{entity:e}of this)if(t(e))return e}filter(t){let e=[];for(let{entity:s}of this)t(s)&&e.push(s);return e}map(t){let e=[];for(let{entity:s}of this)e.push(t(s));return e}getSharedMemory(){return this.list.getSharedMemory()}free(){this.list.free()}}h(k,"ALLOCATE_COUNT",T.ALLOCATE_COUNT);const W=0,vt=1;class E extends G{constructor(e,s){var t=(...De)=>(super(...De),h(this,"ships"),h(this,"moneyMemory"),this);s?(t(e,s),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new k(this.world,{initWithBlock:this.getAllocatedFromMemory(k.ALLOCATE_COUNT)})):(t(e,{size:2+k.ALLOCATE_COUNT,type:v.station}),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new k(this.world,{firstBlock:this.getAllocatedFromMemory(k.ALLOCATE_COUNT)}),this.width=20,this.height=20,this.shields=2,this.maxShields=2,this.timeToRegenerateShields=5),this.key="station"}get money(){return Atomics.load(this.moneyMemory,W)}set money(e){Atomics.store(this.moneyMemory,W,e)}get color(){return this.moneyMemory[vt]}set color(e){this.moneyMemory[vt]=e}addMoney(e){Atomics.add(this.moneyMemory,W,e)}subtractMoney(e){Atomics.sub(this.moneyMemory,W,e)}removeShip(e){this.dead||this.ships.delete(e)}die(){this.dead||(this.ships.forEach(e=>{e.die()}),this.ships.free(),super.die())}}class nt extends G{constructor(e,s){var t=(...Fe)=>(super(...Fe),h(this,"station"),h(this,"uintMemory"),h(this,"velocityMemory"),this);"bufferPosition"in s?(t(e,s),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.station=this.world.getEntityByPointer(this.uintMemory[0])):(t(e,{size:5,type:v.ship}),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.width=10,this.height=5,this.speed=100,this.shields=1,this.maxShields=1,this.timeToRegenerateShields=1,this.station=s.station,this.uintMemory[0]=this.station.pointer)}get speed(){return this.velocityMemory[0]}set speed(e){this.velocityMemory[0]=e}get velocityX(){return this.velocityMemory[1]}set velocityX(e){this.velocityMemory[1]=e}get velocityY(){return this.velocityMemory[2]}set velocityY(e){this.velocityMemory[2]=e}get targetPointer(){return Atomics.load(this.uintMemory,1)}set targetPointer(e){Atomics.store(this.uintMemory,1,e)}get color(){return this.station.color}die(){this.dead||(this.station.removeShip(this),super.die())}}const pe=0,Lt=1,Ut=2,Rt=3,H=class H{constructor(t){h(this,"entities");h(this,"entityCache",new Map);h(this,"bounds");h(this,"heap");h(this,"memory");t?(this.heap=new Nt(t.heap),this.memory=new b(this.heap,t.world),this.entities=new k(this,{firstBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+Rt*this.memory.data.BYTES_PER_ELEMENT}})):(this.heap=new Nt({bufferSize:rt}),this.memory=this.heap.allocUI32(H.ALLOCATE_COUNT),this.entities=new k(this,{initWithBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+Rt*this.memory.data.BYTES_PER_ELEMENT}}));let e=this.memory;this.bounds={get width(){return e.data[Lt]},set width(s){e.data[Lt]=s},get height(){return e.data[Ut]},set height(s){e.data[Ut]=s}}}load(t){t.entities.forEach(e=>{let s;switch(e.type){case"station":s=new E(this);break;default:throw new Error(`Invalid entity type: ${e.type}`)}s.load(e),this.addEntity(s)}),t.bounds&&(this.bounds.width=t.bounds.width,this.bounds.height=t.bounds.height)}addEntity(t){this.entities.insert(t)}removeEntity(t){this.entities.delete(t)}getEntityByPointer(t){if(!t)return;let e=this.entityCache.get(t);if(e!=null&&e.dead&&(this.entityCache.delete(t),e=void 0),!e){let s=new b(this.heap,lt(t)),r=s.data[0];r===v.ship?e=new nt(this,s):r===v.station&&(e=new E(this,s)),e&&this.entityCache.set(t,e)}return e}update(t){this.garbageCollect()}garbageCollect(){this.entities.forEach(t=>{t.dead&&this.entityCache.delete(t.pointer)})}getId(){return Atomics.add(this.memory.data,pe,1)}getSharedMemory(){return{heap:this.heap.getSharedMemory(),world:this.memory.getSharedMemory()}}};h(H,"ALLOCATE_COUNT",3+T.ALLOCATE_COUNT);let at=H;const it=20;class be{constructor(t={name:"System"}){h(this,"name");h(this,"currentDelta",0);h(this,"leftOverDelta",0);h(this,"deltaBetweenRuns");h(this,"firstRun",!0);h(this,"startedAt",0);h(this,"runTimes",[]);this.name=t.name??this.constructor.name,this.deltaBetweenRuns=t.deltaBetweenRuns??0}update(t){if(this.currentDelta+=t,!this.startedAt&&(this.currentDelta>=this.deltaBetweenRuns||this.firstRun)){let e=0;this.deltaBetweenRuns>0&&(e=this.currentDelta%this.deltaBetweenRuns),this.startedAt=performance.now();let s=this.run(this.currentDelta-e);return s instanceof Promise?s.then(()=>{this.finishRun()}):this.finishRun(),this.currentDelta=e,this.firstRun=!1,!0}else return!1}finishRun(){let t=performance.now()-this.startedAt;this.runTimes.push(t),this.runTimes.length>=it*2&&this.runTimes.splice(0,it),this.startedAt=0}destroy(){}getRuntimeStats(){let t=this.runTimes.slice(0,it),s=t.reduce((r,o)=>r+o,0)/t.length;return{min:Math.min(...t),avg:s,max:Math.max(...t),percent:s/(this.deltaBetweenRuns||16.66)}}}class M extends be{constructor(e,s){super(s);h(this,"world");h(this,"worker");h(this,"runningResolve",null);this.world=e,this.worker=s.worker,this.worker.onmessage=o=>{var n;o.data.done&&((n=this.runningResolve)==null||n.call(this),this.runningResolve=null)};const r=e.getSharedMemory();e.heap.onGrowBufferHandlers.push(o=>{}),this.worker.postMessage({init:r})}run(e){return new Promise(s=>{this.runningResolve=s,this.worker.postMessage({elapsedTime:e})})}destroy(){this.worker.terminate()}}function ge(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/velocity-system-m_oMOt3H.js",{name:i==null?void 0:i.name})}function Be(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/update-health-timers-system-BcEZfpMd.js",{name:i==null?void 0:i.name})}function we(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/spawn-ship-system-CPDpBNpP.js",{name:i==null?void 0:i.name})}function Ae(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/collision-system-CYXwL_hr.js",{name:i==null?void 0:i.name})}function ke(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/target-enemy-system-CWhmup99.js",{name:i==null?void 0:i.name})}function Ee(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/move-to-target-system-DEQLz5Z3.js",{name:i==null?void 0:i.name})}class Se extends at{constructor(){super();h(this,"systems",[]);this.initSystems()}update(e){this.systems.forEach(s=>{s.update(e)}),super.update(e)}initSystems(){this.systems.push(new M(this,{name:"velocitySystem",worker:new ge})),this.systems.push(new M(this,{name:"updateHealthTimersSystemWorker",worker:new Be})),this.systems.push(new M(this,{name:"spawnShipSystem",worker:new we})),this.systems.push(new M(this,{name:"collisionSystem",worker:new Ae})),this.systems.push(new M(this,{name:"targetEnemySystem",worker:new ke})),this.systems.push(new M(this,{name:"moveToTargetSystem",worker:new Ee}))}destroy(){this.systems.forEach(e=>e.destroy()),this.systems=[]}}const j=i=>(Kt("data-v-d4f22489"),i=i(),Zt(),i),_e={class:"home"},Me={class:"list"},Te={style:{color:"red"}},Oe=j(()=>w("div",null,null,-1)),Ne=j(()=>w("p",null,null,-1)),Pe=j(()=>w("br",null,null,-1)),Ce=j(()=>w("div",{id:"phaser-container-simple"},null,-1)),Ie=Yt({__name:"SharedMemoryObjects",setup(i){let t=new Se;const e=B(0),s=B(0),r=B(0),o=B(0),n=B(0),u=B(0),f=B(0),d=B([]),g=B([]);let S;Gt(()=>{let O=0,p=[];const m=window.innerWidth/3*2,ut=window.innerHeight/3*2;let K=!1,Z;const U=[];S=new mt.Game({type:mt.AUTO,width:m,height:ut,parent:"phaser-container-simple",scene:{preload(){this.load.image("boid","boid.png"),this.load.image("station","station.png"),this.load.image("shield","shield3.png")},create(){var D;Z=this.add;let ct=performance.now();t.load(Wt({stations:8,shipsPerStation:100,width:m,height:ut}));let R=performance.now();e.value=R-ct;let q=t.entities.filter(l=>l instanceof E);d.value=q.map(l=>{let a="#"+l.color.toString(16);return a==="#ffffff"&&(a="#00000"),{color:l.color,displayColor:a,ships:l.ships.length}}),(D=this.input.keyboard)==null||D.on("keydown-SPACE",()=>{K=!K}),g.value=t.systems.map(l=>({name:l.name,min:0,avg:0,max:0}))},update(ct,R){if(K)return;let q=performance.now();t.entities.forEach(l=>{if(!l.getSprite){let a=Z.image(l.x,l.y,l.key);a.setScale(l.width/a.width,l.height/a.height),a.shieldImage=Z.image(l.x,l.y,"shield"),a.shieldImage.setScale(l.width/a.shieldImage.width*2,l.height/a.shieldImage.height*2),a.shieldImage.visible=l.shields>0,(l instanceof E||l instanceof nt)&&a.setTint(l.color),["x","y","angle"].forEach(c=>{Object.defineProperty(a,c==="angle"?"rotation":c,{get(){return l[c]??0}}),Object.defineProperty(a.shieldImage,c,{get(){return l[c]}})}),["_alphaBL","_alphaBR","_alphaTL","_alphaTR"].forEach(c=>{Object.defineProperty(a.shieldImage,c,{get:()=>l.shields>0?1:0})}),l.getSprite=()=>a,a.entity=l,U.push(a)}}),U.forEach(l=>{l.entity.dead&&(l.destroy(),l.shieldImage.destroy(),U.splice(U.indexOf(l),1))}),t.update(R/1e3);let D=performance.now();if(p.push(D-q),O+=R,O>1e3){s.value=p.reduce((a,c)=>Math.min(a,c),1e6),r.value=p.reduce((a,c)=>Math.max(a,c),0),o.value=p.reduce((a,c)=>a+c,0)/p.length,p=[],O=0,n.value=t.entities.filter(a=>a instanceof E).length,u.value=t.entities.filter(a=>a instanceof nt).length,f.value=t.entities.length;let l=t.entities.filter(a=>a instanceof E);d.value.forEach(a=>{let c=l.find(dt=>dt.color===a.color);c?a.ships=c.ships.length:a.ships>0&&(a.ships=0)}),g.value=t.systems.map(a=>({name:a.name,...a.getRuntimeStats()}))}}}})}),Xt(()=>{S&&(S.destroy(!0),S=null),t&&t.destroy()});function L(){t.entities.filter(p=>p instanceof E).forEach(p=>{p.addMoney(10)})}return(O,p)=>(P(),N("div",_e,[w("div",Me,[w("div",Te,"mainThread: "+y(s.value.toFixed(2))+" - "+y(r.value.toFixed(2))+" ("+y(o.value.toFixed(2))+" avg) ms",1),(P(!0),N(yt,null,pt(g.value,m=>(P(),N("div",{key:m.name},y(m.name)+": "+y(m.max.toFixed(2))+" ("+y(m.avg.toFixed(2))+" avg) ms",1))),128)),Oe,w("div",null,"Memory: "+y(Ht(t).heap.prettyMemory()),1),Ne,w("div",null,"Entities: "+y(n.value)+" stations and "+y(u.value)+" ships ("+y(f.value)+")",1),(P(!0),N(yt,null,pt(d.value,m=>(P(),N("span",{class:"station-list",key:m.color,style:jt({color:m.displayColor})},y("#"+m.color.toString(16))+": "+y(m.ships),5))),128)),Pe,w("button",{onClick:L},"Add Ships")]),Ce]))}}),Ue=qt(Ie,[["__scopeId","data-v-d4f22489"]]);export{Ue as default};
