var $t=Object.defineProperty;var Xt=(u,c,d)=>c in u?$t(u,c,{enumerable:!0,configurable:!0,writable:!0,value:d}):u[c]=d;var l=(u,c,d)=>(Xt(u,typeof c!="symbol"?c+"":c,d),d);(function(){"use strict";function u(r,t,e,i){return(r-e)**2+(t-i)**2}const c=20,d=32-c,X=Math.pow(2,c),H=Math.pow(2,d);function S(r,t=0){return P(Atomics.load(r,t))}function At(r,t=0){return Atomics.load(r,t)}function K(r,t=0,e,i){Atomics.store(r,t,W(e,i))}function Z(r,t=0,e){Atomics.store(r,t,e)}function wt(r,t,e,i){return Atomics.compareExchange(r,t,i,e)===i}function P(r){return{bufferPosition:r&4095,bufferByteOffset:r>>>d}}function W(r,t){return r+(t<<d)}class f{get bufferByteOffset(){return this.data.byteOffset}get pointer(){return W(this.bufferPosition,this.bufferByteOffset)}constructor(t,e){this.memory=t,"buffer"in e?(this.data=e.data,this.buffer=e.buffer,this.bufferPosition=this.memory.buffers.indexOf(e.buffer)):(this.bufferPosition=e.bufferPosition,this.buffer=t.buffers[e.bufferPosition],this.data=new Uint32Array(this.buffer.buf,e.bufferByteOffset))}getArray(t,e,i){return new t(this.data.buffer,this.data.byteOffset+e*t.BYTES_PER_ELEMENT,i)}getArrayMemory(t,e){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset+t*this.data.BYTES_PER_ELEMENT}}free(){this.buffer.free(this.data.byteOffset)}getSharedMemory(){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset}}}const C=0,k=1;function q(r,t=0){for(;Atomics.compareExchange(r,t,C,k)!==C;)"WorkerGlobalScope"in self&&Atomics.wait(r,t,k)}function A(r,t=0){Atomics.compareExchange(r,t,k,C)!==k&&console.warn("We are unlocking when it was not locked!"),Atomics.notify(r,t)}const Et={5120:"i8",5121:"u8",5122:"i16",5123:"u16",5124:"i32",5125:"u32",5126:"f32"},pt={f32:Float32Array,f64:Float64Array},Mt={i8:Int8Array,i16:Int16Array,i32:Int32Array},St={u8:Uint8Array,u8c:Uint8ClampedArray,u16:Uint16Array,u32:Uint32Array},kt={i64:BigInt64Array,u64:BigUint64Array},Tt={...pt,...Mt,...St},_t=r=>{const t=Et[r];return t!==void 0?t:r};function xt(r,...t){const e=kt[r];return new(e||Tt[_t(r)])(...t)}const J=0,Q=1,V=2,tt=3,et=4,B=5,it=6,U=1,D=2,st=8*4,F=0,v=1,m=2*4;class R{constructor(t={}){if(this.buf=t.buf?t.buf:new ArrayBuffer(t.size||4096),this.start=t.start!=null?_(Math.max(t.start,0),4):0,this.u8=new Uint8Array(this.buf),this.u32=new Uint32Array(this.buf),this.state=new Uint32Array(this.buf,this.start,st/4),this.lock=new Int32Array(this.buf,this.start+this.state.byteLength-4,1),!t.skipInitialization){const e=t.align||8;if(e<8)throw new Error(`invalid alignment: ${e}, must be a pow2 and >= 8`);const i=this.initialTop(e),s=t.end!=null?Math.min(t.end,this.buf.byteLength):this.buf.byteLength;if(i>=s)throw new Error(`insufficient address range (0x${this.start.toString(16)} - 0x${s.toString(16)})`);this.align=e,this.doCompact=t.compact!==!1,this.doSplit=t.split!==!1,this.minSplit=t.minSplit||16,this.end=s,this.top=i,this._free=0,this._used=0}}stats(){const t=i=>{let s=0,o=0;for(;i;)if(s++,o+=this.blockSize(i),i=this.blockNext(i),i>this.end){console.error(`Trying to get stats for block past end of buffer: ${i} > ${this.end}`);break}return{count:s,size:o}},e=t(this._free);return{free:e,used:t(this._used),top:this.top,available:this.end-this.top+e.size,total:this.buf.byteLength}}callocAs(t,e,i=0){const s=this.mallocAs(t,e);return s&&s.fill(i),s}mallocAs(t,e){const i=this.malloc(e*Ot[t]);return i?xt(t,this.buf,i,e):void 0}calloc(t,e=0){const i=this.malloc(t);return i&&this.u8.fill(e,i,i+t),i}malloc(t){if(t<=0)return 0;q(this.lock);const e=_(t+m,this.align),i=this.end;let s=this.top,o=this._free,n=0;for(;o;){const h=this.blockSize(o),a=o+h>=s;if(a||h>=e){let y=this.mallocTop(o,n,h,e,a);return A(this.lock),y}n=o,o=this.blockNext(o)}if(o=s,s=o+e,s<=i){this.initBlock(o,e,this._used),this._used=o,this.top=s;let h=w(o);return A(this.lock),h}return A(this.lock),0}mallocTop(t,e,i,s,o){if(o&&t+s>this.end)return 0;if(e?this.unlinkBlock(e,t):this._free=this.blockNext(t),this.setBlockNext(t,this._used),this._used=t,o)this.top=t+this.setBlockSize(t,s);else if(this.doSplit){const n=i-s;n>=this.minSplit&&this.splitBlock(t,s,n)}return w(t)}realloc(t,e){if(e<=0)return 0;const i=T(t);let s=0,o=this._used,n=0;for(;o;){if(o===i){[s,n]=this.reallocBlock(o,e);break}o=this.blockNext(o)}return s&&s!==i&&this.u8.copyWithin(w(s),w(i),n),w(s)}reallocBlock(t,e){const i=this.blockSize(t),s=t+i,o=s>=this.top,n=_(e+m,this.align);if(n<=i){if(this.doSplit){const h=i-n;h>=this.minSplit?this.splitBlock(t,n,h):o&&(this.top=t+n)}else o&&(this.top=t+n);return[t,s]}return o&&t+n<this.end?(this.top=t+this.setBlockSize(t,n),[t,s]):(this.free(t),[T(this.malloc(e)),s])}reallocArray(t,e){if(t.buffer!==this.buf)return;const i=this.realloc(t.byteOffset,e*t.BYTES_PER_ELEMENT);return i?new t.constructor(this.buf,i,e):void 0}bytesFor(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return;e=t.byteOffset}else e=t;e=T(e);let i=this._used;for(;i;){if(i===e)return this.blockSize(e)-m;i=this.blockNext(i)}}lengthOf(t){let e=this.bytesFor(t);if(e)return e/this.u32.BYTES_PER_ELEMENT}free(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return!1;e=t.byteOffset}else e=t;q(this.lock),e=T(e);let i=this._used,s=0;for(;i;){if(i===e)return s?this.unlinkBlock(s,i):this._used=this.blockNext(i),this.insert(i),this.doCompact&&this.compact(),A(this.lock),!0;s=i,i=this.blockNext(i)}return A(this.lock),!1}freeAll(){this._free=0,this._used=0,this.top=this.initialTop()}release(){return delete this.u8,delete this.u32,delete this.state,delete this.buf,!0}get align(){return this.state[et]}set align(t){this.state[et]=t}get end(){return this.state[tt]}set end(t){this.state[tt]=t}get top(){return Atomics.load(this.state,V)}set top(t){Atomics.store(this.state,V,t)}get _free(){return Atomics.load(this.state,J)}set _free(t){Atomics.store(this.state,J,t)}get _used(){return Atomics.load(this.state,Q)}set _used(t){Atomics.store(this.state,Q,t)}get doCompact(){return!!(this.state[B]&U)}set doCompact(t){t?this.state[B]|=1<<U-1:this.state[B]&=~U}get doSplit(){return!!(this.state[B]&D)}set doSplit(t){t?this.state[B]|=1<<D-1:this.state[B]&=~D}get minSplit(){return this.state[it]}set minSplit(t){if(t<=m)throw new Error(`illegal min split threshold: ${t}, require at least ${m+1}`);this.state[it]=t}blockSize(t){return Atomics.load(this.u32,(t>>2)+F)}setBlockSize(t,e){return Atomics.store(this.u32,(t>>2)+F,e),e}blockNext(t){return Atomics.load(this.u32,(t>>2)+v)}setBlockNext(t,e){Atomics.store(this.u32,(t>>2)+v,e)}initBlock(t,e,i){const s=t>>>2;return Atomics.store(this.u32,s+F,e),Atomics.store(this.u32,s+v,i),t}unlinkBlock(t,e){this.setBlockNext(t,this.blockNext(e))}splitBlock(t,e,i){this.insert(this.initBlock(t+this.setBlockSize(t,e),i,0)),this.doCompact&&this.compact()}initialTop(t=this.align){return _(this.start+st+m,t)-m}compact(){let t=this._free,e=0,i=0,s,o=!1;for(;t;){for(s=t,i=this.blockNext(t);i&&s+this.blockSize(s)===i;)s=i,i=this.blockNext(i);if(s!==t){const n=s-t+this.blockSize(s);this.setBlockSize(t,n);const h=this.blockNext(s);let a=this.blockNext(t);for(;a&&a!==h;){const y=this.blockNext(a);this.setBlockNext(a,0),a=y}this.setBlockNext(t,h),o=!0}t+this.blockSize(t)>=this.top&&(this.top=t,e?this.unlinkBlock(e,t):this._free=this.blockNext(t)),e=t,t=this.blockNext(t)}return o}insert(t){let e=this._free,i=0;for(;e&&!(t<=e);)i=e,e=this.blockNext(e);i?this.setBlockNext(i,t):this._free=t,this.setBlockNext(t,e)}}const w=r=>r>0?r+m:0,T=r=>r>0?r-m:0,_=(r,t)=>(t--,r+t&~t),Ot={u8:1,u8c:1,i8:1,u16:2,i16:2,u32:4,i32:4,i64:8,u64:8,f32:4,f64:8},Nt=["B","kB","MB","GB","TB","PB","EB","ZB","YB"],It=["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],Lt=["b","kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],Pt=["b","kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],rt=(r,t,e)=>{let i=r;return typeof t=="string"||Array.isArray(t)?i=r.toLocaleString(t,e):(t===!0||e!==void 0)&&(i=r.toLocaleString(void 0,e)),i};function Ct(r,t){if(!Number.isFinite(r))throw new TypeError(`Expected a finite number, got ${typeof r}: ${r}`);t={bits:!1,binary:!1,space:!0,...t};const e=t.bits?t.binary?Pt:Lt:t.binary?It:Nt,i=t.space?" ":"";if(t.signed&&r===0)return` 0${i}${e[0]}`;const s=r<0,o=s?"-":t.signed?"+":"";s&&(r=-r);let n;if(t.minimumFractionDigits!==void 0&&(n={minimumFractionDigits:t.minimumFractionDigits}),t.maximumFractionDigits!==void 0&&(n={maximumFractionDigits:t.maximumFractionDigits,...n}),r<1){const M=rt(r,t.locale,n);return o+M+i+e[0]}const h=Math.min(Math.floor(t.binary?Math.log(r)/Math.log(1024):Math.log10(r)/3),e.length-1);r/=(t.binary?1024:1e3)**h,n||(r=r.toPrecision(3));const a=rt(Number(r),t.locale,n),y=e[h];return o+a+i+y}const Ut=8192,ot=0,nt=1;class ht{constructor(t){if(this.onGrowBufferHandlers=[],t&&"buffers"in t)this.buffers=t.buffers.map(e=>new R({buf:e,skipInitialization:!0})),this.memory=new f(this,{bufferPosition:0,bufferByteOffset:40}),this.isClone=!0;else{const e=(t==null?void 0:t.bufferSize)??Ut;if(e>X)throw new Error(`Buffer size ${e} is greater than max ${X} that we can reference with pointers`);let i=this.createBuffer(e);this.buffers=[i];const s=i.callocAs("u32",2);if(s)this.memory=new f(this,{bufferPosition:0,bufferByteOffset:s.byteOffset});else throw new Error("Failed to initialize first byte from buffer");this.memory.data[ot]=e,this.memory.data[nt]=1,this.isClone=!1;for(let o=1;o<((t==null?void 0:t.initialBuffers)??1);o++)this.buffers.push(this.createBuffer(e))}}get bufferSize(){return this.memory.data[ot]}addSharedBuffer(t){this.buffers[t.bufferPosition]=new R({buf:t.buffer,skipInitialization:!0})}createBuffer(t){return new R({buf:new SharedArrayBuffer(t??this.bufferSize),compact:!1,split:!1})}addOnGrowBufferHandlers(t){this.onGrowBufferHandlers.push(t)}allocUI32(t){for(let o=0;o<this.buffers.length;o++){const n=this.buffers[o];if(!n)continue;const h=n.callocAs("u32",t);if(h)return new f(this,{data:h,buffer:n})}if(this.buffers.length>=H)throw new Error(`Can't initialize a new buffer since it would have a position greater than the max of ${H}`);const e=this.createBuffer();let i=Atomics.add(this.memory.data,nt,1);this.buffers[i]=e,this.onGrowBufferHandlers.forEach(o=>o({bufferPosition:i,buffer:e.buf}));const s=e.callocAs("u32",t);if(s)return new f(this,{data:s,buffer:e});throw new Error(`Unable to allocate ${t} numbers even after adding a new buffer`)}getSharedAlloc(t){if(this.buffers[t.bufferPosition]!==void 0)return new f(this,t)}get currentUsed(){return this.totalAllocated-this.buffers.reduce((t,e)=>t+e.stats().available,0)}get totalAllocated(){return this.buffers[0].buf.byteLength*this.buffers.length}prettyMemory(){return`${at(this.currentUsed)} / ${at(this.totalAllocated)}`}getSharedMemory(){return{buffers:this.buffers.map(t=>t.buf)}}}function at(r){return Ct(r,{binary:!0,minimumFractionDigits:1,maximumFractionDigits:1})}const lt=4,ft=1,E=2,$=class ${get length(){return Atomics.load(this.firstBlock.data,E)}get type(){return Atomics.load(this.uint16Array,0)}set type(t){Atomics.store(this.uint16Array,0,t)}get dataLength(){return Math.max(1,Atomics.load(this.uint16Array,1))}set dataLength(t){Atomics.store(this.uint16Array,1,t)}constructor(t,e){if(this.memory=t,e&&"firstBlock"in e)this.firstBlock=new f(t,e.firstBlock),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(E+1)*Uint32Array.BYTES_PER_ELEMENT,2);else{e&&e.initWithBlock?this.firstBlock=new f(t,e.initWithBlock):this.firstBlock=t.allocUI32(lt),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(E+1)*Uint32Array.BYTES_PER_ELEMENT,2);const i=(e==null?void 0:e.type)??Uint32Array;i===Uint32Array?this.type=0:i===Int32Array?this.type=1:i===Float32Array&&(this.type=2),this.dataLength=(e==null?void 0:e.dataLength)??1}}insert(t){typeof t=="number"&&(t=[t]);let e=this.dataLength;if(t.length>e)throw new Error(`Can't insert ${t.length} array into shared list of ${e} dataLength`);let i=this.memory.allocUI32(ft+e),s=this.getDataBlock(i.data),o=i.pointer;for(let a=0;a<t.length;a++)s instanceof Int32Array||s instanceof Uint32Array?Atomics.store(s,a,t[a]):s[a]=t[a];let n,h=!1;for(;!h;)n=At(this.firstBlock.data,1),h=wt(this.firstBlock.data,1,o,n);if(n){let{bufferPosition:a,bufferByteOffset:y}=P(n),M=new Uint32Array(this.memory.buffers[a].buf,y,1);Z(M,0,o)}else Z(this.firstBlock.data,0,o);Atomics.add(this.firstBlock.data,E,1)}deleteMatch(t){for(let{data:e,index:i,deleteCurrent:s}of this)if(t(e,i))return s(),!0;return!1}deleteIndex(t){return t>=this.length||t<0?!1:this.deleteMatch((e,i)=>i===t)}deleteValue(t){return typeof t=="number"?this.deleteMatch(e=>e[0]===t):this.deleteMatch(e=>{if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0})}*[Symbol.iterator](){let t=0,{bufferPosition:e,bufferByteOffset:i}=S(this.firstBlock.data,0),s=this.firstBlock.data,o=0,n=0;for(;i;){let h=this.memory.buffers[e];if(!h)return;let a=new Uint32Array(h.buf,i,2),y=this.getDataBlock(a),M=e,jt=i;({bufferPosition:e,bufferByteOffset:i}=S(a,0));let gt=!0;yield{data:y,index:t,deleteCurrent:()=>{K(s,0,e,i),i||K(this.firstBlock.data,1,o,n),h.free(a.byteOffset),Atomics.sub(this.firstBlock.data,E,1),gt=!1}},gt&&(s=a,o=M,n=jt,t++)}}forEach(t){for(let e of this)t(e.data)}getSharedMemory(){return{firstBlock:this.firstBlock.getSharedMemory()}}getDataBlock(t){const e=t.byteOffset+ft*t.BYTES_PER_ELEMENT;switch(this.type){case 1:return new Int32Array(t.buffer,e,this.dataLength);case 0:return new Uint32Array(t.buffer,e,this.dataLength);case 2:return new Float32Array(t.buffer,e,this.dataLength);default:throw new Error(`Unknown data block type ${this.type}`)}}free(){let{bufferPosition:t,bufferByteOffset:e}=S(this.firstBlock.data,0);for(;e;){let i=new f(this.memory,{bufferPosition:t,bufferByteOffset:e});({bufferPosition:t,bufferByteOffset:e}=S(i.data,0)),i.free()}this.firstBlock.free()}};$.ALLOCATE_COUNT=lt;let g=$;const Dt=new ArrayBuffer(8);new BigUint64Array(Dt);const Ft=0,z=1,ut=2,I=class I{constructor(t,e){l(this,"world");l(this,"memory");l(this,"takenMemoryBytes",0);l(this,"_id");l(this,"positionMemory");l(this,"key","boid");l(this,"shieldMemory");l(this,"getSprite");this.world=t,"size"in e?(this.memory=t.heap.allocUI32(e.size+I.ALLOCATE_COUNT),this.memory.data[z]=t.getId(),this.memory.data[Ft]=e.type):e instanceof f?this.memory=e:this.memory=new f(t.heap,e),this._id=this.memory.data[z],this.takenMemoryBytes+=3*this.memory.data.BYTES_PER_ELEMENT,this.positionMemory=this.getArrayFromMemory(Float32Array,5),this.shieldMemory=this.getArrayFromMemory(Float32Array,5)}get id(){return this._id}get dead(){return this._id!==this.memory.data[z]||!!this.memory.data[ut]}set dead(t){this.memory.data[ut]=t?1:0}get x(){return this.positionMemory[0]}set x(t){this.positionMemory[0]=t}get y(){return this.positionMemory[1]}set y(t){this.positionMemory[1]=t}get width(){return this.positionMemory[2]}set width(t){this.positionMemory[2]=t}get height(){return this.positionMemory[3]}set height(t){this.positionMemory[3]=t}get angle(){return this.positionMemory[4]}set angle(t){this.positionMemory[4]=t}get shields(){return this.shieldMemory[0]}set shields(t){this.shieldMemory[0]=t}get maxShields(){return this.shieldMemory[1]}set maxShields(t){this.shieldMemory[1]=t}get timeToRegenerateShields(){return this.shieldMemory[2]}set timeToRegenerateShields(t){this.shieldMemory[2]=t}get timeSinceShieldRegeneration(){return this.shieldMemory[3]}set timeSinceShieldRegeneration(t){this.shieldMemory[3]=t}get timeSinceTakenDamage(){return this.shieldMemory[4]}set timeSinceTakenDamage(t){this.shieldMemory[4]=t}load(t){Object.keys(t).forEach(e=>{this[e]=t[e]})}die(){this.dead=!0,this.world.removeEntity(this),this.memory.free()}canTakeDamage(){return this.timeSinceTakenDamage>=.2&&!this.dead}takeDamage(t){this.canTakeDamage()&&(this.shields-=t,this.timeSinceTakenDamage=0,this.shields<0&&this.die())}getArrayFromMemory(t,e){let i=this.getAllocatedFromMemory(e);return new t(this.memory.data.buffer,i.bufferByteOffset,e)}getAllocatedFromMemory(t){let e=this.takenMemoryBytes;return this.takenMemoryBytes+=t*4,{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+e}}get pointer(){return this.memory.pointer}};l(I,"ALLOCATE_COUNT",13);let x=I;var p=(r=>(r[r.ship=1]="ship",r[r.station=2]="station",r))(p||{});class G extends x{constructor(e,i){var t=(...Ht)=>(super(...Ht),l(this,"station"),l(this,"uintMemory"),l(this,"velocityMemory"),this);"bufferPosition"in i?(t(e,i),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.station=this.world.getEntityByPointer(this.uintMemory[0])):(t(e,{size:5,type:p.ship}),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.width=10,this.height=5,this.speed=100,this.shields=1,this.maxShields=1,this.timeToRegenerateShields=1,this.station=i.station,this.uintMemory[0]=this.station.pointer)}get speed(){return this.velocityMemory[0]}set speed(e){this.velocityMemory[0]=e}get velocityX(){return this.velocityMemory[1]}set velocityX(e){this.velocityMemory[1]=e}get velocityY(){return this.velocityMemory[2]}set velocityY(e){this.velocityMemory[2]=e}get targetPointer(){return Atomics.load(this.uintMemory,1)}set targetPointer(e){Atomics.store(this.uintMemory,1,e)}get color(){var e;return((e=this.station)==null?void 0:e.color)??0}die(){var e;this.dead||((e=this.station)==null||e.removeShip(this),super.die())}}class b{constructor(t,e){l(this,"world");l(this,"list");l(this,"entityCache",new Map);this.world=t,e?this.list=new g(t.heap,e):this.list=new g(t.heap)}get length(){return this.list.length}insert(t){this.list.insert(t.pointer),this.entityCache.set(t.pointer,t)}delete(t){return this.entityCache.delete(t.pointer),this.list.deleteValue(t.pointer)}*[Symbol.iterator](){let t=this.list[Symbol.iterator]();for(let{data:e,deleteCurrent:i}of t){let s=Atomics.load(e,0),o=this.world.getEntityByPointer(s);o&&(yield{entity:o,deleteCurrent:i})}}forEach(t,e){for(let{entity:i}of this)(!e||e(i))&&t(i)}find(t){for(let{entity:e}of this)if(t(e))return e}filter(t){let e=[];for(let{entity:i}of this)t(i)&&e.push(i);return e}map(t){let e=[];for(let{entity:i}of this)e.push(t(i));return e}getSharedMemory(){return this.list.getSharedMemory()}free(){this.list.free()}}l(b,"ALLOCATE_COUNT",g.ALLOCATE_COUNT);const O=0,ct=1;class N extends x{constructor(e,i){var t=(...Kt)=>(super(...Kt),l(this,"ships"),l(this,"moneyMemory"),this);i?(t(e,i),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new b(this.world,{initWithBlock:this.getAllocatedFromMemory(b.ALLOCATE_COUNT)})):(t(e,{size:2+b.ALLOCATE_COUNT,type:p.station}),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new b(this.world,{firstBlock:this.getAllocatedFromMemory(b.ALLOCATE_COUNT)}),this.width=20,this.height=20,this.shields=2,this.maxShields=2,this.timeToRegenerateShields=5),this.key="station"}get money(){return Atomics.load(this.moneyMemory,O)}set money(e){Atomics.store(this.moneyMemory,O,e)}get color(){return this.moneyMemory[ct]}set color(e){this.moneyMemory[ct]=e}addMoney(e){Atomics.add(this.moneyMemory,O,e)}subtractMoney(e){Atomics.sub(this.moneyMemory,O,e)}removeShip(e){this.dead||this.ships.delete(e)}die(){this.dead||(this.ships.forEach(e=>{e.die()}),this.ships.free(),super.die())}}const vt=0,dt=1,mt=2,yt=3,L=class L{constructor(t){l(this,"entities");l(this,"entityCache",new Map);l(this,"bounds");l(this,"heap");l(this,"memory");t?(this.heap=new ht(t.heap),this.memory=new f(this.heap,t.world),this.entities=new b(this,{firstBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+yt*this.memory.data.BYTES_PER_ELEMENT}})):(this.heap=new ht({bufferSize:1024*100}),this.memory=this.heap.allocUI32(L.ALLOCATE_COUNT),this.entities=new b(this,{initWithBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+yt*this.memory.data.BYTES_PER_ELEMENT}}));let e=this.memory;this.bounds={get width(){return e.data[dt]},set width(i){e.data[dt]=i},get height(){return e.data[mt]},set height(i){e.data[mt]=i}}}load(t){t.entities.forEach(e=>{let i;switch(e.type){case"station":i=new N(this);break;default:throw new Error(`Invalid entity type: ${e.type}`)}i.load(e),this.addEntity(i)}),t.bounds&&(this.bounds.width=t.bounds.width,this.bounds.height=t.bounds.height)}addEntity(t){this.entities.insert(t)}removeEntity(t){this.entities.delete(t)}getEntityByPointer(t){if(!t)return;let e=this.entityCache.get(t);if(e!=null&&e.dead&&(this.entityCache.delete(t),e=void 0),!e){let i=new f(this.heap,P(t)),s=i.data[0];s===p.ship?e=new G(this,i):s===p.station&&(e=new N(this,i)),e&&this.entityCache.set(t,e)}return e}update(t){try{this.garbageCollect()}catch{}}garbageCollect(){this.entities.forEach(t=>{t.dead&&this.entityCache.delete(t.pointer)})}growMemoryFromThread(t,e){t.forEach(i=>this.heap.addSharedBuffer(i))}getId(){return Atomics.add(this.memory.data,vt,1)}getSharedMemory(){return{heap:this.heap.getSharedMemory(),world:this.memory.getSharedMemory()}}};l(L,"ALLOCATE_COUNT",3+g.ALLOCATE_COUNT);let Y=L;function Rt(r){let t,e,i={memoryGrown:[]};self.onmessage=function(s){if(s.data.init)t=new Y(s.data.init),e=r(t),t.heap.addOnGrowBufferHandlers(o=>i.memoryGrown.push(o));else if(s.data.elapsedTime){s.data.memoryGrown.forEach(n=>t.heap.addSharedBuffer(n));try{e.run(s.data.elapsedTime),t.garbageCollect()}catch{}self.postMessage({done:!0,...i}),i={memoryGrown:[]}}}}class j{constructor(t,e=0){this.bounds={x:t.x||0,y:t.y||0,width:t.width,height:t.height},this.maxObjects=typeof t.maxObjects=="number"?t.maxObjects:10,this.maxLevels=typeof t.maxLevels=="number"?t.maxLevels:4,this.level=e,this.objects=[],this.nodes=[]}getIndex(t){return t.qtIndex(this.bounds)}split(){const t=this.level+1,e=this.bounds.width/2,i=this.bounds.height/2,s=this.bounds.x,o=this.bounds.y,n=[{x:s+e,y:o},{x:s,y:o},{x:s,y:o+i},{x:s+e,y:o+i}];for(let h=0;h<4;h++)this.nodes[h]=new j({x:n[h].x,y:n[h].y,width:e,height:i,maxObjects:this.maxObjects,maxLevels:this.maxLevels},t)}insert(t){if(this.nodes.length){const e=this.getIndex(t);for(let i=0;i<e.length;i++)this.nodes[e[i]].insert(t);return}if(this.objects.push(t),this.objects.length>this.maxObjects&&this.level<this.maxLevels){this.nodes.length||this.split();for(let e=0;e<this.objects.length;e++){const i=this.getIndex(this.objects[e]);for(let s=0;s<i.length;s++)this.nodes[i[s]].insert(this.objects[e])}this.objects=[]}}retrieve(t){const e=this.getIndex(t);let i=this.objects;if(this.nodes.length)for(let s=0;s<e.length;s++)i=i.concat(this.nodes[e[s]].retrieve(t));return this.level===0?Array.from(new Set(i)):i}remove(t,e=!1){const i=this.objects.indexOf(t);i>-1&&this.objects.splice(i,1);for(let s=0;s<this.nodes.length;s++)this.nodes[s].remove(t);return this.level===0&&!e&&this.join(),i!==-1}update(t,e=!1){this.remove(t,e),this.insert(t)}join(){let t=Array.from(this.objects);for(let i=0;i<this.nodes.length;i++){const s=this.nodes[i].join();t=t.concat(s)}const e=Array.from(new Set(t));if(e.length<=this.maxObjects){this.objects=e;for(let i=0;i<this.nodes.length;i++)this.nodes[i].objects=[];this.nodes=[]}return t}clear(){this.objects=[];for(let t=0;t<this.nodes.length;t++)this.nodes.length&&this.nodes[t].clear();this.nodes=[]}}class bt{constructor(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this.data=t.data}qtIndex(t){const e=[],i=t.x+t.width/2,s=t.y+t.height/2,o=this.y<s,n=this.x<i,h=this.x+this.width>i,a=this.y+this.height>s;return o&&h&&e.push(0),n&&o&&e.push(1),n&&a&&e.push(2),h&&a&&e.push(3),e}}class zt{constructor(t){l(this,"world");this.world=t}run(){let t=new j({width:this.world.bounds.width,height:this.world.bounds.height});this.world.entities.forEach(i=>{t.insert(new bt({x:i.x,y:i.y,width:i.width,height:i.height,data:{entity:i}}))}),this.world.entities.filter(i=>i instanceof G).forEach(i=>{let s=Gt(t,i);i.targetPointer=(s==null?void 0:s.pointer)??0})}}function Gt(r,t){let e=Yt(r,t,i=>i instanceof N?i!==t.station:i instanceof G?i.station!==t.station:!1);if(e)return e;{let i=t.world.entities.filter(s=>s instanceof N&&s!==t.station);return i.sort((s,o)=>u(s.x,s.y,t.x,t.y)-u(o.x,o.y,t.x,t.y)),i[0]}}function Yt(r,t,e){let i={x:t.x-50,y:t.y-50,width:t.width+100,height:t.height+100},s=Bt(r,i).filter(o=>o!==t&&!o.dead&&e(o));return s.length===0&&(i.x-=100,i.y-=100,i.width+=200,i.height+=200,s=Bt(r,i).filter(o=>o!==t&&e(o))),s.sort((o,n)=>u(o.x,o.y,t.x,t.y)-u(n.x,n.y,t.x,t.y)),s[0]??null}function Bt(r,t){return r.retrieve(new bt(t)).map(e=>e.data.entity)}Rt(r=>new zt(r))})();
