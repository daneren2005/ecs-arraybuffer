var Rt=Object.defineProperty;var vt=(b,d,y)=>d in b?Rt(b,d,{enumerable:!0,configurable:!0,writable:!0,value:y}):b[d]=y;var h=(b,d,y)=>(vt(b,typeof d!="symbol"?d+"":d,y),y);(function(){"use strict";const y=Math.pow(2,20),$=Math.pow(2,12);function M(r,t=0){return C(Atomics.load(r,t))}function mt(r,t=0){return Atomics.load(r,t)}function X(r,t=0,e,i){Atomics.store(r,t,K(e,i))}function H(r,t=0,e){Atomics.store(r,t,e)}function bt(r,t,e,i){return Atomics.compareExchange(r,t,i,e)===i}function C(r){return{bufferPosition:r&4095,bufferByteOffset:r>>>12}}function K(r,t){return r+(t<<12)}class l{get bufferByteOffset(){return this.data.byteOffset}get pointer(){return K(this.bufferPosition,this.bufferByteOffset)}constructor(t,e){this.memory=t,"buffer"in e?(this.data=e.data,this.buffer=e.buffer,this.bufferPosition=this.memory.buffers.indexOf(e.buffer)):(this.bufferPosition=e.bufferPosition,this.buffer=t.buffers[e.bufferPosition],this.data=new Uint32Array(this.buffer.buf,e.bufferByteOffset))}getArray(t,e,i){return new t(this.data.buffer,this.data.byteOffset+e*t.BYTES_PER_ELEMENT,i)}getArrayMemory(t,e){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset+t*this.data.BYTES_PER_ELEMENT}}free(){this.buffer.free(this.data.byteOffset)}getSharedMemory(){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset}}}const U=0,S=1;function Z(r,t=0){for(;Atomics.compareExchange(r,t,U,S)!==U;)"WorkerGlobalScope"in self&&Atomics.wait(r,t,S)}function E(r,t=0){Atomics.compareExchange(r,t,S,U)!==S&&console.warn("We are unlocking when it was not locked!"),Atomics.notify(r,t)}const Bt={5120:"i8",5121:"u8",5122:"i16",5123:"u16",5124:"i32",5125:"u32",5126:"f32"},At={f32:Float32Array,f64:Float64Array},Et={i8:Int8Array,i16:Int16Array,i32:Int32Array},pt={u8:Uint8Array,u8c:Uint8ClampedArray,u16:Uint16Array,u32:Uint32Array},Tt={i64:BigInt64Array,u64:BigUint64Array},gt={...At,...Et,...pt},wt=r=>{const t=Bt[r];return t!==void 0?t:r};function Mt(r,...t){const e=Tt[r];return new(e||gt[wt(r)])(...t)}const W=0,j=1,q=2,J=3,Q=4,B=5,V=6,L=1,x=2,tt=8*4,F=0,D=1,u=2*4;class R{constructor(t={}){if(this.buf=t.buf?t.buf:new ArrayBuffer(t.size||4096),this.start=t.start!=null?k(Math.max(t.start,0),4):0,this.u8=new Uint8Array(this.buf),this.u32=new Uint32Array(this.buf),this.state=new Uint32Array(this.buf,this.start,tt/4),this.lock=new Int32Array(this.buf,this.start+this.state.byteLength-4,1),!t.skipInitialization){const e=t.align||8;if(e<8)throw new Error(`invalid alignment: ${e}, must be a pow2 and >= 8`);const i=this.initialTop(e),s=t.end!=null?Math.min(t.end,this.buf.byteLength):this.buf.byteLength;if(i>=s)throw new Error(`insufficient address range (0x${this.start.toString(16)} - 0x${s.toString(16)})`);this.align=e,this.doCompact=t.compact!==!1,this.doSplit=t.split!==!1,this.minSplit=t.minSplit||16,this.end=s,this.top=i,this._free=0,this._used=0}}stats(){const t=i=>{let s=0,o=0;for(;i;)if(s++,o+=this.blockSize(i),i=this.blockNext(i),i>this.end){console.error(`Trying to get stats for block past end of buffer: ${i} > ${this.end}`);break}return{count:s,size:o}},e=t(this._free);return{free:e,used:t(this._used),top:this.top,available:this.end-this.top+e.size,total:this.buf.byteLength}}callocAs(t,e,i=0){const s=this.mallocAs(t,e);return s&&s.fill(i),s}mallocAs(t,e){const i=this.malloc(e*St[t]);return i?Mt(t,this.buf,i,e):void 0}calloc(t,e=0){const i=this.malloc(t);return i&&this.u8.fill(e,i,i+t),i}malloc(t){if(t<=0)return 0;Z(this.lock);const e=k(t+u,this.align),i=this.end;let s=this.top,o=this._free,n=0;for(;o;){const a=this.blockSize(o),f=o+a>=s;if(f||a>=e){let c=this.mallocTop(o,n,a,e,f);return E(this.lock),c}n=o,o=this.blockNext(o)}if(o=s,s=o+e,s<=i){this.initBlock(o,e,this._used),this._used=o,this.top=s;let a=p(o);return E(this.lock),a}return E(this.lock),0}mallocTop(t,e,i,s,o){if(o&&t+s>this.end)return 0;if(e?this.unlinkBlock(e,t):this._free=this.blockNext(t),this.setBlockNext(t,this._used),this._used=t,o)this.top=t+this.setBlockSize(t,s);else if(this.doSplit){const n=i-s;n>=this.minSplit&&this.splitBlock(t,s,n)}return p(t)}realloc(t,e){if(e<=0)return 0;const i=_(t);let s=0,o=this._used,n=0;for(;o;){if(o===i){[s,n]=this.reallocBlock(o,e);break}o=this.blockNext(o)}return s&&s!==i&&this.u8.copyWithin(p(s),p(i),n),p(s)}reallocBlock(t,e){const i=this.blockSize(t),s=t+i,o=s>=this.top,n=k(e+u,this.align);if(n<=i){if(this.doSplit){const a=i-n;a>=this.minSplit?this.splitBlock(t,n,a):o&&(this.top=t+n)}else o&&(this.top=t+n);return[t,s]}return o&&t+n<this.end?(this.top=t+this.setBlockSize(t,n),[t,s]):(this.free(t),[_(this.malloc(e)),s])}reallocArray(t,e){if(t.buffer!==this.buf)return;const i=this.realloc(t.byteOffset,e*t.BYTES_PER_ELEMENT);return i?new t.constructor(this.buf,i,e):void 0}bytesFor(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return;e=t.byteOffset}else e=t;e=_(e);let i=this._used;for(;i;){if(i===e)return this.blockSize(e)-u;i=this.blockNext(i)}}lengthOf(t){let e=this.bytesFor(t);if(e)return e/this.u32.BYTES_PER_ELEMENT}free(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return!1;e=t.byteOffset}else e=t;Z(this.lock),e=_(e);let i=this._used,s=0;for(;i;){if(i===e)return s?this.unlinkBlock(s,i):this._used=this.blockNext(i),this.insert(i),this.doCompact&&this.compact(),E(this.lock),!0;s=i,i=this.blockNext(i)}return E(this.lock),!1}freeAll(){this._free=0,this._used=0,this.top=this.initialTop()}release(){return delete this.u8,delete this.u32,delete this.state,delete this.buf,!0}get align(){return this.state[Q]}set align(t){this.state[Q]=t}get end(){return this.state[J]}set end(t){this.state[J]=t}get top(){return Atomics.load(this.state,q)}set top(t){Atomics.store(this.state,q,t)}get _free(){return Atomics.load(this.state,W)}set _free(t){Atomics.store(this.state,W,t)}get _used(){return Atomics.load(this.state,j)}set _used(t){Atomics.store(this.state,j,t)}get doCompact(){return!!(this.state[B]&L)}set doCompact(t){t?this.state[B]|=1<<L-1:this.state[B]&=~L}get doSplit(){return!!(this.state[B]&x)}set doSplit(t){t?this.state[B]|=1<<x-1:this.state[B]&=~x}get minSplit(){return this.state[V]}set minSplit(t){if(t<=u)throw new Error(`illegal min split threshold: ${t}, require at least ${u+1}`);this.state[V]=t}blockSize(t){return Atomics.load(this.u32,(t>>2)+F)}setBlockSize(t,e){return Atomics.store(this.u32,(t>>2)+F,e),e}blockNext(t){return Atomics.load(this.u32,(t>>2)+D)}setBlockNext(t,e){Atomics.store(this.u32,(t>>2)+D,e)}initBlock(t,e,i){const s=t>>>2;return Atomics.store(this.u32,s+F,e),Atomics.store(this.u32,s+D,i),t}unlinkBlock(t,e){this.setBlockNext(t,this.blockNext(e))}splitBlock(t,e,i){this.insert(this.initBlock(t+this.setBlockSize(t,e),i,0)),this.doCompact&&this.compact()}initialTop(t=this.align){return k(this.start+tt+u,t)-u}compact(){let t=this._free,e=0,i=0,s,o=!1;for(;t;){for(s=t,i=this.blockNext(t);i&&s+this.blockSize(s)===i;)s=i,i=this.blockNext(i);if(s!==t){const n=s-t+this.blockSize(s);this.setBlockSize(t,n);const a=this.blockNext(s);let f=this.blockNext(t);for(;f&&f!==a;){const c=this.blockNext(f);this.setBlockNext(f,0),f=c}this.setBlockNext(t,a),o=!0}t+this.blockSize(t)>=this.top&&(this.top=t,e?this.unlinkBlock(e,t):this._free=this.blockNext(t)),e=t,t=this.blockNext(t)}return o}insert(t){let e=this._free,i=0;for(;e&&!(t<=e);)i=e,e=this.blockNext(e);i?this.setBlockNext(i,t):this._free=t,this.setBlockNext(t,e)}}const p=r=>r>0?r+u:0,_=r=>r>0?r-u:0,k=(r,t)=>(t--,r+t&~t),St={u8:1,u8c:1,i8:1,u16:2,i16:2,u32:4,i32:4,i64:8,u64:8,f32:4,f64:8},_t=["B","kB","MB","GB","TB","PB","EB","ZB","YB"],kt=["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],Ot=["b","kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],Nt=["b","kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],et=(r,t,e)=>{let i=r;return typeof t=="string"||Array.isArray(t)?i=r.toLocaleString(t,e):(t===!0||e!==void 0)&&(i=r.toLocaleString(void 0,e)),i};function It(r,t){if(!Number.isFinite(r))throw new TypeError(`Expected a finite number, got ${typeof r}: ${r}`);t={bits:!1,binary:!1,space:!0,...t};const e=t.bits?t.binary?Nt:Ot:t.binary?kt:_t,i=t.space?" ":"";if(t.signed&&r===0)return` 0${i}${e[0]}`;const s=r<0,o=s?"-":t.signed?"+":"";s&&(r=-r);let n;if(t.minimumFractionDigits!==void 0&&(n={minimumFractionDigits:t.minimumFractionDigits}),t.maximumFractionDigits!==void 0&&(n={maximumFractionDigits:t.maximumFractionDigits,...n}),r<1){const w=et(r,t.locale,n);return o+w+i+e[0]}const a=Math.min(Math.floor(t.binary?Math.log(r)/Math.log(1024):Math.log10(r)/3),e.length-1);r/=(t.binary?1024:1e3)**a,n||(r=r.toPrecision(3));const f=et(Number(r),t.locale,n),c=e[a];return o+f+i+c}const Pt=8192,it=0,st=1;class rt{constructor(t){if(this.onGrowBufferHandlers=[],t&&"buffers"in t)this.buffers=t.buffers.map(e=>new R({buf:e,skipInitialization:!0})),this.memory=new l(this,{bufferPosition:0,bufferByteOffset:40}),this.isClone=!0;else{const e=(t==null?void 0:t.bufferSize)??Pt;if(e>y)throw new Error(`Buffer size ${e} is greater than max ${y} that we can reference with pointers`);let i=this.createBuffer(e);this.buffers=[i];const s=i.callocAs("u32",2);if(s)this.memory=new l(this,{bufferPosition:0,bufferByteOffset:s.byteOffset});else throw new Error("Failed to initialize first byte from buffer");this.memory.data[it]=e,this.memory.data[st]=1,this.isClone=!1;for(let o=1;o<((t==null?void 0:t.initialBuffers)??1);o++)this.buffers.push(this.createBuffer(e))}}get bufferSize(){return this.memory.data[it]}addSharedBuffer(t){this.buffers[t.bufferPosition]=new R({buf:t.buffer,skipInitialization:!0})}createBuffer(t){return new R({buf:new SharedArrayBuffer(t??this.bufferSize),compact:!1,split:!1})}addOnGrowBufferHandlers(t){this.onGrowBufferHandlers.push(t)}allocUI32(t){for(let o=0;o<this.buffers.length;o++){const n=this.buffers[o];if(!n)continue;const a=n.callocAs("u32",t);if(a)return new l(this,{data:a,buffer:n})}if(this.buffers.length>=$)throw new Error(`Can't initialize a new buffer since it would have a position greater than the max of ${$}`);const e=this.createBuffer();let i=Atomics.add(this.memory.data,st,1);this.buffers[i]=e,this.onGrowBufferHandlers.forEach(o=>o({bufferPosition:i,buffer:e.buf}));const s=e.callocAs("u32",t);if(s)return new l(this,{data:s,buffer:e});throw new Error(`Unable to allocate ${t} numbers even after adding a new buffer`)}getSharedAlloc(t){if(this.buffers[t.bufferPosition]!==void 0)return new l(this,t)}get currentUsed(){return this.totalAllocated-this.buffers.reduce((t,e)=>t+e.stats().available,0)}get totalAllocated(){return this.buffers[0].buf.byteLength*this.buffers.length}prettyMemory(){return`${ot(this.currentUsed)} / ${ot(this.totalAllocated)}`}getSharedMemory(){return{buffers:this.buffers.map(t=>t.buf)}}}function ot(r){return It(r,{binary:!0,minimumFractionDigits:1,maximumFractionDigits:1})}const nt=4,ht=1,T=2,G=class G{get length(){return Atomics.load(this.firstBlock.data,T)}get type(){return Atomics.load(this.uint16Array,0)}set type(t){Atomics.store(this.uint16Array,0,t)}get dataLength(){return Math.max(1,Atomics.load(this.uint16Array,1))}set dataLength(t){Atomics.store(this.uint16Array,1,t)}constructor(t,e){if(this.memory=t,e&&"firstBlock"in e)this.firstBlock=new l(t,e.firstBlock),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(T+1)*Uint32Array.BYTES_PER_ELEMENT,2);else{e&&e.initWithBlock?this.firstBlock=new l(t,e.initWithBlock):this.firstBlock=t.allocUI32(nt),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(T+1)*Uint32Array.BYTES_PER_ELEMENT,2);const i=(e==null?void 0:e.type)??Uint32Array;i===Uint32Array?this.type=0:i===Int32Array?this.type=1:i===Float32Array&&(this.type=2),this.dataLength=(e==null?void 0:e.dataLength)??1}}insert(t){typeof t=="number"&&(t=[t]);let e=this.dataLength;if(t.length>e)throw new Error(`Can't insert ${t.length} array into shared list of ${e} dataLength`);let i=this.memory.allocUI32(ht+e),s=this.getDataBlock(i.data),o=i.pointer;for(let f=0;f<t.length;f++)s instanceof Int32Array||s instanceof Uint32Array?Atomics.store(s,f,t[f]):s[f]=t[f];let n,a=!1;for(;!a;)n=mt(this.firstBlock.data,1),a=bt(this.firstBlock.data,1,o,n);if(n){let{bufferPosition:f,bufferByteOffset:c}=C(n),w=new Uint32Array(this.memory.buffers[f].buf,c,1);H(w,0,o)}else H(this.firstBlock.data,0,o);Atomics.add(this.firstBlock.data,T,1)}deleteMatch(t){for(let{data:e,index:i,deleteCurrent:s}of this)if(t(e,i))return s(),!0;return!1}deleteIndex(t){return t>=this.length||t<0?!1:this.deleteMatch((e,i)=>i===t)}deleteValue(t){return typeof t=="number"?this.deleteMatch(e=>e[0]===t):this.deleteMatch(e=>{if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0})}*[Symbol.iterator](){let t=0,{bufferPosition:e,bufferByteOffset:i}=M(this.firstBlock.data,0),s=this.firstBlock.data,o=0,n=0;for(;i;){let a=this.memory.buffers[e];if(!a)return;let f=new Uint32Array(a.buf,i,2),c=this.getDataBlock(f),w=e,Dt=i;({bufferPosition:e,bufferByteOffset:i}=M(f,0));let yt=!0;yield{data:c,index:t,deleteCurrent:()=>{X(s,0,e,i),i||X(this.firstBlock.data,1,o,n),a.free(f.byteOffset),Atomics.sub(this.firstBlock.data,T,1),yt=!1}},yt&&(s=f,o=w,n=Dt,t++)}}forEach(t){for(let e of this)t(e.data)}getSharedMemory(){return{firstBlock:this.firstBlock.getSharedMemory()}}getDataBlock(t){const e=t.byteOffset+ht*t.BYTES_PER_ELEMENT;switch(this.type){case 1:return new Int32Array(t.buffer,e,this.dataLength);case 0:return new Uint32Array(t.buffer,e,this.dataLength);case 2:return new Float32Array(t.buffer,e,this.dataLength);default:throw new Error(`Unknown data block type ${this.type}`)}}free(){let{bufferPosition:t,bufferByteOffset:e}=M(this.firstBlock.data,0);for(;e;){let i=new l(this.memory,{bufferPosition:t,bufferByteOffset:e});({bufferPosition:t,bufferByteOffset:e}=M(i.data,0)),i.free()}this.firstBlock.free()}};G.ALLOCATE_COUNT=nt;let A=G;const Ct=new ArrayBuffer(8);new BigUint64Array(Ct);const Ut=0,v=1,at=2,I=class I{constructor(t,e){h(this,"world");h(this,"memory");h(this,"takenMemoryBytes",0);h(this,"_id");h(this,"positionMemory");h(this,"key","boid");h(this,"shieldMemory");h(this,"getSprite");this.world=t,"size"in e?(this.memory=t.heap.allocUI32(e.size+I.ALLOCATE_COUNT),this.memory.data[v]=t.getId(),this.memory.data[Ut]=e.type):e instanceof l?this.memory=e:this.memory=new l(t.heap,e),this._id=this.memory.data[v],this.takenMemoryBytes+=3*this.memory.data.BYTES_PER_ELEMENT,this.positionMemory=this.getArrayFromMemory(Float32Array,5),this.shieldMemory=this.getArrayFromMemory(Float32Array,5)}get id(){return this._id}get dead(){return this._id!==this.memory.data[v]||!!this.memory.data[at]}set dead(t){this.memory.data[at]=t?1:0}get x(){return this.positionMemory[0]}set x(t){this.positionMemory[0]=t}get y(){return this.positionMemory[1]}set y(t){this.positionMemory[1]=t}get width(){return this.positionMemory[2]}set width(t){this.positionMemory[2]=t}get height(){return this.positionMemory[3]}set height(t){this.positionMemory[3]=t}get angle(){return this.positionMemory[4]}set angle(t){this.positionMemory[4]=t}get shields(){return this.shieldMemory[0]}set shields(t){this.shieldMemory[0]=t}get maxShields(){return this.shieldMemory[1]}set maxShields(t){this.shieldMemory[1]=t}get timeToRegenerateShields(){return this.shieldMemory[2]}set timeToRegenerateShields(t){this.shieldMemory[2]=t}get timeSinceShieldRegeneration(){return this.shieldMemory[3]}set timeSinceShieldRegeneration(t){this.shieldMemory[3]=t}get timeSinceTakenDamage(){return this.shieldMemory[4]}set timeSinceTakenDamage(t){this.shieldMemory[4]=t}load(t){Object.keys(t).forEach(e=>{this[e]=t[e]})}die(){this.dead=!0,this.world.removeEntity(this),this.memory.free()}canTakeDamage(){return this.timeSinceTakenDamage>=.2&&!this.dead}takeDamage(t){this.canTakeDamage()&&(this.shields-=t,this.timeSinceTakenDamage=0,this.shields<0&&this.die())}getArrayFromMemory(t,e){let i=this.getAllocatedFromMemory(e);return new t(this.memory.data.buffer,i.bufferByteOffset,e)}getAllocatedFromMemory(t){let e=this.takenMemoryBytes;return this.takenMemoryBytes+=t*4,{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+e}}get pointer(){return this.memory.pointer}};h(I,"ALLOCATE_COUNT",13);let O=I;var g=(r=>(r[r.ship=1]="ship",r[r.station=2]="station",r))(g||{});class ft extends O{constructor(e,i){var t=(...zt)=>(super(...zt),h(this,"station"),h(this,"uintMemory"),h(this,"velocityMemory"),this);"bufferPosition"in i?(t(e,i),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.station=this.world.getEntityByPointer(this.uintMemory[0])):(t(e,{size:5,type:g.ship}),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.width=10,this.height=5,this.speed=100,this.shields=1,this.maxShields=1,this.timeToRegenerateShields=1,this.station=i.station,this.uintMemory[0]=this.station.pointer)}get speed(){return this.velocityMemory[0]}set speed(e){this.velocityMemory[0]=e}get velocityX(){return this.velocityMemory[1]}set velocityX(e){this.velocityMemory[1]=e}get velocityY(){return this.velocityMemory[2]}set velocityY(e){this.velocityMemory[2]=e}get targetPointer(){return Atomics.load(this.uintMemory,1)}set targetPointer(e){Atomics.store(this.uintMemory,1,e)}get color(){var e;return((e=this.station)==null?void 0:e.color)??0}die(){var e;this.dead||((e=this.station)==null||e.removeShip(this),super.die())}}class m{constructor(t,e){h(this,"world");h(this,"list");h(this,"entityCache",new Map);this.world=t,e?this.list=new A(t.heap,e):this.list=new A(t.heap)}get length(){return this.list.length}insert(t){this.list.insert(t.pointer),this.entityCache.set(t.pointer,t)}delete(t){return this.entityCache.delete(t.pointer),this.list.deleteValue(t.pointer)}*[Symbol.iterator](){let t=this.list[Symbol.iterator]();for(let{data:e,deleteCurrent:i}of t){let s=Atomics.load(e,0),o=this.world.getEntityByPointer(s);o&&(yield{entity:o,deleteCurrent:i})}}forEach(t,e){for(let{entity:i}of this)(!e||e(i))&&t(i)}find(t){for(let{entity:e}of this)if(t(e))return e}filter(t){let e=[];for(let{entity:i}of this)t(i)&&e.push(i);return e}map(t){let e=[];for(let{entity:i}of this)e.push(t(i));return e}getSharedMemory(){return this.list.getSharedMemory()}free(){this.list.free()}}h(m,"ALLOCATE_COUNT",A.ALLOCATE_COUNT);const N=0,lt=1;class z extends O{constructor(e,i){var t=(...Yt)=>(super(...Yt),h(this,"ships"),h(this,"moneyMemory"),this);i?(t(e,i),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new m(this.world,{initWithBlock:this.getAllocatedFromMemory(m.ALLOCATE_COUNT)})):(t(e,{size:2+m.ALLOCATE_COUNT,type:g.station}),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new m(this.world,{firstBlock:this.getAllocatedFromMemory(m.ALLOCATE_COUNT)}),this.width=20,this.height=20,this.shields=2,this.maxShields=2,this.timeToRegenerateShields=5),this.key="station"}get money(){return Atomics.load(this.moneyMemory,N)}set money(e){Atomics.store(this.moneyMemory,N,e)}get color(){return this.moneyMemory[lt]}set color(e){this.moneyMemory[lt]=e}addMoney(e){Atomics.add(this.moneyMemory,N,e)}subtractMoney(e){Atomics.sub(this.moneyMemory,N,e)}removeShip(e){this.dead||this.ships.delete(e)}die(){this.dead||(this.ships.forEach(e=>{e.die()}),this.ships.free(),super.die())}}const Lt=0,ut=1,ct=2,dt=3,P=class P{constructor(t){h(this,"entities");h(this,"entityCache",new Map);h(this,"bounds");h(this,"heap");h(this,"memory");t?(this.heap=new rt(t.heap),this.memory=new l(this.heap,t.world),this.entities=new m(this,{firstBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+dt*this.memory.data.BYTES_PER_ELEMENT}})):(this.heap=new rt({bufferSize:1024*100}),this.memory=this.heap.allocUI32(P.ALLOCATE_COUNT),this.entities=new m(this,{initWithBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+dt*this.memory.data.BYTES_PER_ELEMENT}}));let e=this.memory;this.bounds={get width(){return e.data[ut]},set width(i){e.data[ut]=i},get height(){return e.data[ct]},set height(i){e.data[ct]=i}}}load(t){t.entities.forEach(e=>{let i;switch(e.type){case"station":i=new z(this);break;default:throw new Error(`Invalid entity type: ${e.type}`)}i.load(e),this.addEntity(i)}),t.bounds&&(this.bounds.width=t.bounds.width,this.bounds.height=t.bounds.height)}addEntity(t){this.entities.insert(t)}removeEntity(t){this.entities.delete(t)}getEntityByPointer(t){if(!t)return;let e=this.entityCache.get(t);if(e!=null&&e.dead&&(this.entityCache.delete(t),e=void 0),!e){let i=new l(this.heap,C(t)),s=i.data[0];s===g.ship?e=new ft(this,i):s===g.station&&(e=new z(this,i)),e&&this.entityCache.set(t,e)}return e}update(t){try{this.garbageCollect()}catch{}}garbageCollect(){this.entities.forEach(t=>{t.dead&&this.entityCache.delete(t.pointer)})}growMemoryFromThread(t,e){t.forEach(i=>this.heap.addSharedBuffer(i))}getId(){return Atomics.add(this.memory.data,Lt,1)}getSharedMemory(){return{heap:this.heap.getSharedMemory(),world:this.memory.getSharedMemory()}}};h(P,"ALLOCATE_COUNT",3+A.ALLOCATE_COUNT);let Y=P;function xt(r){let t,e,i={memoryGrown:[]};self.onmessage=function(s){if(s.data.init)t=new Y(s.data.init),e=r(t),t.heap.addOnGrowBufferHandlers(o=>i.memoryGrown.push(o));else if(s.data.elapsedTime){s.data.memoryGrown.forEach(n=>t.heap.addSharedBuffer(n));try{e.run(s.data.elapsedTime),t.garbageCollect()}catch{}self.postMessage({done:!0,...i}),i={memoryGrown:[]}}}}class Ft{constructor(t){h(this,"world");this.world=t}run(){this.world.entities.filter(e=>e instanceof z).forEach(e=>{if(e.money>0){let i=new ft(this.world,{station:e});i.x=e.x,i.y=e.y,i.velocityX=(Math.random()>.5?-1:1)*Math.random()*i.speed,i.velocityY=(Math.random()>.5?-1:1)*Math.random()*i.speed,e.ships.insert(i),this.world.addEntity(i),e.subtractMoney(1)}})}}xt(r=>new Ft(r))})();
