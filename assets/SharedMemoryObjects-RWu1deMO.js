var $t=Object.defineProperty;var Gt=(i,t,e)=>t in i?$t(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var h=(i,t,e)=>(Gt(i,typeof t!="symbol"?t+"":t,e),e);import{P as dt,g as Yt}from"./generate-scene-oCWeBa7x.js";import{d as Xt,r as B,o as Ht,a as Kt,c as N,b as A,t as y,F as mt,e as yt,u as jt,f as P,n as Zt,p as qt,g as Jt,_ as Qt}from"./index-BLx1M3Ps.js";const zt=20,at=32-zt,pt=Math.pow(2,zt),bt=Math.pow(2,at);function F(i,t=0){return ht(Atomics.load(i,t))}function Vt(i,t=0){return Atomics.load(i,t)}function gt(i,t=0,e,s){Atomics.store(i,t,Wt(e,s))}function Bt(i,t=0,e){Atomics.store(i,t,e)}function te(i,t,e,s){return Atomics.compareExchange(i,t,s,e)===s}function ht(i){return{bufferPosition:i&4095,bufferByteOffset:i>>>at}}function Wt(i,t){return i+(t<<at)}class p{get bufferByteOffset(){return this.data.byteOffset}get pointer(){return Wt(this.bufferPosition,this.bufferByteOffset)}constructor(t,e){this.memory=t,"buffer"in e?(this.data=e.data,this.buffer=e.buffer,this.bufferPosition=this.memory.buffers.indexOf(e.buffer)):(this.bufferPosition=e.bufferPosition,this.buffer=t.buffers[e.bufferPosition],this.data=new Uint32Array(this.buffer.buf,e.bufferByteOffset))}getArray(t,e,s){return new t(this.data.buffer,this.data.byteOffset+e*t.BYTES_PER_ELEMENT,s)}getArrayMemory(t,e){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset+t*this.data.BYTES_PER_ELEMENT}}free(){this.buffer.free(this.data.byteOffset)}getSharedMemory(){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset}}}const rt=0,G=1;function wt(i,t=0){for(;Atomics.compareExchange(i,t,rt,G)!==rt;)"WorkerGlobalScope"in self&&Atomics.wait(i,t,G)}function I(i,t=0){Atomics.compareExchange(i,t,G,rt)!==G&&console.warn("We are unlocking when it was not locked!"),Atomics.notify(i,t)}const ee={5120:"i8",5121:"u8",5122:"i16",5123:"u16",5124:"i32",5125:"u32",5126:"f32"},se={f32:Float32Array,f64:Float64Array},ie={i8:Int8Array,i16:Int16Array,i32:Int32Array},re={u8:Uint8Array,u8c:Uint8ClampedArray,u16:Uint16Array,u32:Uint32Array},ne={i64:BigInt64Array,u64:BigUint64Array},oe={...se,...ie,...re},ae=i=>{const t=ee[i];return t!==void 0?t:i};function he(i,...t){const e=ne[i];return new(e||oe[ae(i)])(...t)}const At=0,Et=1,kt=2,St=3,_t=4,T=5,Tt=6,J=1,Q=2,Mt=8*4,V=0,tt=1,w=2*4;class et{constructor(t={}){if(this.buf=t.buf?t.buf:new ArrayBuffer(t.size||4096),this.start=t.start!=null?W(Math.max(t.start,0),4):0,this.u8=new Uint8Array(this.buf),this.u32=new Uint32Array(this.buf),this.state=new Uint32Array(this.buf,this.start,Mt/4),this.lock=new Int32Array(this.buf,this.start+this.state.byteLength-4,1),!t.skipInitialization){const e=t.align||8;if(e<8)throw new Error(`invalid alignment: ${e}, must be a pow2 and >= 8`);const s=this.initialTop(e),r=t.end!=null?Math.min(t.end,this.buf.byteLength):this.buf.byteLength;if(s>=r)throw new Error(`insufficient address range (0x${this.start.toString(16)} - 0x${r.toString(16)})`);this.align=e,this.doCompact=t.compact!==!1,this.doSplit=t.split!==!1,this.minSplit=t.minSplit||16,this.end=r,this.top=s,this._free=0,this._used=0}}stats(){const t=s=>{let r=0,n=0;for(;s;)if(r++,n+=this.blockSize(s),s=this.blockNext(s),s>this.end){console.error(`Trying to get stats for block past end of buffer: ${s} > ${this.end}`);break}return{count:r,size:n}},e=t(this._free);return{free:e,used:t(this._used),top:this.top,available:this.end-this.top+e.size,total:this.buf.byteLength}}callocAs(t,e,s=0){const r=this.mallocAs(t,e);return r&&r.fill(s),r}mallocAs(t,e){const s=this.malloc(e*le[t]);return s?he(t,this.buf,s,e):void 0}calloc(t,e=0){const s=this.malloc(t);return s&&this.u8.fill(e,s,s+t),s}malloc(t){if(t<=0)return 0;wt(this.lock);const e=W(t+w,this.align),s=this.end;let r=this.top,n=this._free,o=0;for(;n;){const f=this.blockSize(n),u=n+f>=r;if(u||f>=e){let d=this.mallocTop(n,o,f,e,u);return I(this.lock),d}o=n,n=this.blockNext(n)}if(n=r,r=n+e,r<=s){this.initBlock(n,e,this._used),this._used=n,this.top=r;let f=x(n);return I(this.lock),f}return I(this.lock),0}mallocTop(t,e,s,r,n){if(n&&t+r>this.end)return 0;if(e?this.unlinkBlock(e,t):this._free=this.blockNext(t),this.setBlockNext(t,this._used),this._used=t,n)this.top=t+this.setBlockSize(t,r);else if(this.doSplit){const o=s-r;o>=this.minSplit&&this.splitBlock(t,r,o)}return x(t)}realloc(t,e){if(e<=0)return 0;const s=z(t);let r=0,n=this._used,o=0;for(;n;){if(n===s){[r,o]=this.reallocBlock(n,e);break}n=this.blockNext(n)}return r&&r!==s&&this.u8.copyWithin(x(r),x(s),o),x(r)}reallocBlock(t,e){const s=this.blockSize(t),r=t+s,n=r>=this.top,o=W(e+w,this.align);if(o<=s){if(this.doSplit){const f=s-o;f>=this.minSplit?this.splitBlock(t,o,f):n&&(this.top=t+o)}else n&&(this.top=t+o);return[t,r]}return n&&t+o<this.end?(this.top=t+this.setBlockSize(t,o),[t,r]):(this.free(t),[z(this.malloc(e)),r])}reallocArray(t,e){if(t.buffer!==this.buf)return;const s=this.realloc(t.byteOffset,e*t.BYTES_PER_ELEMENT);return s?new t.constructor(this.buf,s,e):void 0}bytesFor(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return;e=t.byteOffset}else e=t;e=z(e);let s=this._used;for(;s;){if(s===e)return this.blockSize(e)-w;s=this.blockNext(s)}}lengthOf(t){let e=this.bytesFor(t);if(e)return e/this.u32.BYTES_PER_ELEMENT}free(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return!1;e=t.byteOffset}else e=t;wt(this.lock),e=z(e);let s=this._used,r=0;for(;s;){if(s===e)return r?this.unlinkBlock(r,s):this._used=this.blockNext(s),this.insert(s),this.doCompact&&this.compact(),I(this.lock),!0;r=s,s=this.blockNext(s)}return I(this.lock),!1}freeAll(){this._free=0,this._used=0,this.top=this.initialTop()}release(){return delete this.u8,delete this.u32,delete this.state,delete this.buf,!0}get align(){return this.state[_t]}set align(t){this.state[_t]=t}get end(){return this.state[St]}set end(t){this.state[St]=t}get top(){return Atomics.load(this.state,kt)}set top(t){Atomics.store(this.state,kt,t)}get _free(){return Atomics.load(this.state,At)}set _free(t){Atomics.store(this.state,At,t)}get _used(){return Atomics.load(this.state,Et)}set _used(t){Atomics.store(this.state,Et,t)}get doCompact(){return!!(this.state[T]&J)}set doCompact(t){t?this.state[T]|=1<<J-1:this.state[T]&=~J}get doSplit(){return!!(this.state[T]&Q)}set doSplit(t){t?this.state[T]|=1<<Q-1:this.state[T]&=~Q}get minSplit(){return this.state[Tt]}set minSplit(t){if(t<=w)throw new Error(`illegal min split threshold: ${t}, require at least ${w+1}`);this.state[Tt]=t}blockSize(t){return Atomics.load(this.u32,(t>>2)+V)}setBlockSize(t,e){return Atomics.store(this.u32,(t>>2)+V,e),e}blockNext(t){return Atomics.load(this.u32,(t>>2)+tt)}setBlockNext(t,e){Atomics.store(this.u32,(t>>2)+tt,e)}initBlock(t,e,s){const r=t>>>2;return Atomics.store(this.u32,r+V,e),Atomics.store(this.u32,r+tt,s),t}unlinkBlock(t,e){this.setBlockNext(t,this.blockNext(e))}splitBlock(t,e,s){this.insert(this.initBlock(t+this.setBlockSize(t,e),s,0)),this.doCompact&&this.compact()}initialTop(t=this.align){return W(this.start+Mt+w,t)-w}compact(){let t=this._free,e=0,s=0,r,n=!1;for(;t;){for(r=t,s=this.blockNext(t);s&&r+this.blockSize(r)===s;)r=s,s=this.blockNext(s);if(r!==t){const o=r-t+this.blockSize(r);this.setBlockSize(t,o);const f=this.blockNext(r);let u=this.blockNext(t);for(;u&&u!==f;){const d=this.blockNext(u);this.setBlockNext(u,0),u=d}this.setBlockNext(t,f),n=!0}t+this.blockSize(t)>=this.top&&(this.top=t,e?this.unlinkBlock(e,t):this._free=this.blockNext(t)),e=t,t=this.blockNext(t)}return n}insert(t){let e=this._free,s=0;for(;e&&!(t<=e);)s=e,e=this.blockNext(e);s?this.setBlockNext(s,t):this._free=t,this.setBlockNext(t,e)}}const x=i=>i>0?i+w:0,z=i=>i>0?i-w:0,W=(i,t)=>(t--,i+t&~t),le={u8:1,u8c:1,i8:1,u16:2,i16:2,u32:4,i32:4,i64:8,u64:8,f32:4,f64:8},fe=["B","kB","MB","GB","TB","PB","EB","ZB","YB"],ue=["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],ce=["b","kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],de=["b","kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],Ot=(i,t,e)=>{let s=i;return typeof t=="string"||Array.isArray(t)?s=i.toLocaleString(t,e):(t===!0||e!==void 0)&&(s=i.toLocaleString(void 0,e)),s};function me(i,t){if(!Number.isFinite(i))throw new TypeError(`Expected a finite number, got ${typeof i}: ${i}`);t={bits:!1,binary:!1,space:!0,...t};const e=t.bits?t.binary?de:ce:t.binary?ue:fe,s=t.space?" ":"";if(t.signed&&i===0)return` 0${s}${e[0]}`;const r=i<0,n=r?"-":t.signed?"+":"";r&&(i=-i);let o;if(t.minimumFractionDigits!==void 0&&(o={minimumFractionDigits:t.minimumFractionDigits}),t.maximumFractionDigits!==void 0&&(o={maximumFractionDigits:t.maximumFractionDigits,...o}),i<1){const g=Ot(i,t.locale,o);return n+g+s+e[0]}const f=Math.min(Math.floor(t.binary?Math.log(i)/Math.log(1024):Math.log10(i)/3),e.length-1);i/=(t.binary?1024:1e3)**f,o||(i=i.toPrecision(3));const u=Ot(Number(i),t.locale,o),d=e[f];return n+u+s+d}const ye=8192,Nt=0,Pt=1;class It{constructor(t){if(this.onGrowBufferHandlers=[],t&&"buffers"in t)this.buffers=t.buffers.map(e=>new et({buf:e,skipInitialization:!0})),this.memory=new p(this,{bufferPosition:0,bufferByteOffset:40}),this.isClone=!0;else{const e=(t==null?void 0:t.bufferSize)??ye;if(e>pt)throw new Error(`Buffer size ${e} is greater than max ${pt} that we can reference with pointers`);let s=this.createBuffer(e);this.buffers=[s];const r=s.callocAs("u32",2);if(r)this.memory=new p(this,{bufferPosition:0,bufferByteOffset:r.byteOffset});else throw new Error("Failed to initialize first byte from buffer");this.memory.data[Nt]=e,this.memory.data[Pt]=1,this.isClone=!1;for(let n=1;n<((t==null?void 0:t.initialBuffers)??1);n++)this.buffers.push(this.createBuffer(e))}}get bufferSize(){return this.memory.data[Nt]}addSharedBuffer(t){this.buffers[t.bufferPosition]=new et({buf:t.buffer,skipInitialization:!0})}createBuffer(t){return new et({buf:new SharedArrayBuffer(t??this.bufferSize),compact:!1,split:!1})}addOnGrowBufferHandlers(t){this.onGrowBufferHandlers.push(t)}allocUI32(t){for(let n=0;n<this.buffers.length;n++){const o=this.buffers[n];if(!o)continue;const f=o.callocAs("u32",t);if(f)return new p(this,{data:f,buffer:o})}if(this.buffers.length>=bt)throw new Error(`Can't initialize a new buffer since it would have a position greater than the max of ${bt}`);const e=this.createBuffer();let s=Atomics.add(this.memory.data,Pt,1);this.buffers[s]=e,this.onGrowBufferHandlers.forEach(n=>n({bufferPosition:s,buffer:e.buf}));const r=e.callocAs("u32",t);if(r)return new p(this,{data:r,buffer:e});throw new Error(`Unable to allocate ${t} numbers even after adding a new buffer`)}getSharedAlloc(t){if(this.buffers[t.bufferPosition]!==void 0)return new p(this,t)}get currentUsed(){return this.totalAllocated-this.buffers.reduce((t,e)=>t+e.stats().available,0)}get totalAllocated(){return this.buffers[0].buf.byteLength*this.buffers.length}prettyMemory(){return`${xt(this.currentUsed)} / ${xt(this.totalAllocated)}`}getSharedMemory(){return{buffers:this.buffers.map(t=>t.buf)}}}function xt(i){return me(i,{binary:!0,minimumFractionDigits:1,maximumFractionDigits:1})}const vt=4,Ct=1,v=2,lt=class lt{get length(){return Atomics.load(this.firstBlock.data,v)}get type(){return Atomics.load(this.uint16Array,0)}set type(t){Atomics.store(this.uint16Array,0,t)}get dataLength(){return Math.max(1,Atomics.load(this.uint16Array,1))}set dataLength(t){Atomics.store(this.uint16Array,1,t)}constructor(t,e){if(this.memory=t,e&&"firstBlock"in e)this.firstBlock=new p(t,e.firstBlock),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(v+1)*Uint32Array.BYTES_PER_ELEMENT,2);else{e&&e.initWithBlock?this.firstBlock=new p(t,e.initWithBlock):this.firstBlock=t.allocUI32(vt),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(v+1)*Uint32Array.BYTES_PER_ELEMENT,2);const s=(e==null?void 0:e.type)??Uint32Array;s===Uint32Array?this.type=0:s===Int32Array?this.type=1:s===Float32Array&&(this.type=2),this.dataLength=(e==null?void 0:e.dataLength)??1}}insert(t){typeof t=="number"&&(t=[t]);let e=this.dataLength;if(t.length>e)throw new Error(`Can't insert ${t.length} array into shared list of ${e} dataLength`);let s=this.memory.allocUI32(Ct+e),r=this.getDataBlock(s.data),n=s.pointer;for(let u=0;u<t.length;u++)r instanceof Int32Array||r instanceof Uint32Array?Atomics.store(r,u,t[u]):r[u]=t[u];let o,f=!1;for(;!f;)o=Vt(this.firstBlock.data,1),f=te(this.firstBlock.data,1,n,o);if(o){let{bufferPosition:u,bufferByteOffset:d}=ht(o),g=new Uint32Array(this.memory.buffers[u].buf,d,1);Bt(g,0,n)}else Bt(this.firstBlock.data,0,n);Atomics.add(this.firstBlock.data,v,1)}deleteMatch(t){for(let{data:e,index:s,deleteCurrent:r}of this)if(t(e,s))return r(),!0;return!1}deleteIndex(t){return t>=this.length||t<0?!1:this.deleteMatch((e,s)=>s===t)}deleteValue(t){return typeof t=="number"?this.deleteMatch(e=>e[0]===t):this.deleteMatch(e=>{if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0})}*[Symbol.iterator](){let t=0,{bufferPosition:e,bufferByteOffset:s}=F(this.firstBlock.data,0),r=this.firstBlock.data,n=0,o=0;for(;s;){let f=this.memory.buffers[e];if(!f)return;let u=new Uint32Array(f.buf,s,2),d=this.getDataBlock(u),g=e,_=s;({bufferPosition:e,bufferByteOffset:s}=F(u,0));let U=!0;yield{data:d,index:t,deleteCurrent:()=>{gt(r,0,e,s),s||gt(this.firstBlock.data,1,n,o),f.free(u.byteOffset),Atomics.sub(this.firstBlock.data,v,1),U=!1}},U&&(r=u,n=g,o=_,t++)}}forEach(t){for(let e of this)t(e.data)}getSharedMemory(){return{firstBlock:this.firstBlock.getSharedMemory()}}getDataBlock(t){const e=t.byteOffset+Ct*t.BYTES_PER_ELEMENT;switch(this.type){case 1:return new Int32Array(t.buffer,e,this.dataLength);case 0:return new Uint32Array(t.buffer,e,this.dataLength);case 2:return new Float32Array(t.buffer,e,this.dataLength);default:throw new Error(`Unknown data block type ${this.type}`)}}free(){let{bufferPosition:t,bufferByteOffset:e}=F(this.firstBlock.data,0);for(;e;){let s=new p(this.memory,{bufferPosition:t,bufferByteOffset:e});({bufferPosition:t,bufferByteOffset:e}=F(s.data,0)),s.free()}this.firstBlock.free()}};lt.ALLOCATE_COUNT=vt;let M=lt;const pe=new ArrayBuffer(8);new BigUint64Array(pe);const be=0,st=1,Ut=2,X=class X{constructor(t,e){h(this,"world");h(this,"memory");h(this,"takenMemoryBytes",0);h(this,"_id");h(this,"positionMemory");h(this,"key","boid");h(this,"shieldMemory");h(this,"getSprite");this.world=t,"size"in e?(this.memory=t.heap.allocUI32(e.size+X.ALLOCATE_COUNT),this.memory.data[st]=t.getId(),this.memory.data[be]=e.type):e instanceof p?this.memory=e:this.memory=new p(t.heap,e),this._id=this.memory.data[st],this.takenMemoryBytes+=3*this.memory.data.BYTES_PER_ELEMENT,this.positionMemory=this.getArrayFromMemory(Float32Array,5),this.shieldMemory=this.getArrayFromMemory(Float32Array,5)}get id(){return this._id}get dead(){return this._id!==this.memory.data[st]||!!this.memory.data[Ut]}set dead(t){this.memory.data[Ut]=t?1:0}get x(){return this.positionMemory[0]}set x(t){this.positionMemory[0]=t}get y(){return this.positionMemory[1]}set y(t){this.positionMemory[1]=t}get width(){return this.positionMemory[2]}set width(t){this.positionMemory[2]=t}get height(){return this.positionMemory[3]}set height(t){this.positionMemory[3]=t}get angle(){return this.positionMemory[4]}set angle(t){this.positionMemory[4]=t}get shields(){return this.shieldMemory[0]}set shields(t){this.shieldMemory[0]=t}get maxShields(){return this.shieldMemory[1]}set maxShields(t){this.shieldMemory[1]=t}get timeToRegenerateShields(){return this.shieldMemory[2]}set timeToRegenerateShields(t){this.shieldMemory[2]=t}get timeSinceShieldRegeneration(){return this.shieldMemory[3]}set timeSinceShieldRegeneration(t){this.shieldMemory[3]=t}get timeSinceTakenDamage(){return this.shieldMemory[4]}set timeSinceTakenDamage(t){this.shieldMemory[4]=t}load(t){Object.keys(t).forEach(e=>{this[e]=t[e]})}die(){this.dead=!0,this.world.removeEntity(this),this.memory.free()}canTakeDamage(){return this.timeSinceTakenDamage>=.2&&!this.dead}takeDamage(t){this.canTakeDamage()&&(this.shields-=t,this.timeSinceTakenDamage=0,this.shields<0&&this.die())}getArrayFromMemory(t,e){let s=this.getAllocatedFromMemory(e);return new t(this.memory.data.buffer,s.bufferByteOffset,e)}getAllocatedFromMemory(t){let e=this.takenMemoryBytes;return this.takenMemoryBytes+=t*4,{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+e}}get pointer(){return this.memory.pointer}};h(X,"ALLOCATE_COUNT",13);let Y=X;var C=(i=>(i[i.ship=1]="ship",i[i.station=2]="station",i))(C||{});class E{constructor(t,e){h(this,"world");h(this,"list");h(this,"entityCache",new Map);this.world=t,e?this.list=new M(t.heap,e):this.list=new M(t.heap)}get length(){return this.list.length}insert(t){this.list.insert(t.pointer),this.entityCache.set(t.pointer,t)}delete(t){return this.entityCache.delete(t.pointer),this.list.deleteValue(t.pointer)}*[Symbol.iterator](){let t=this.list[Symbol.iterator]();for(let{data:e,deleteCurrent:s}of t){let r=Atomics.load(e,0),n=this.world.getEntityByPointer(r);n&&(yield{entity:n,deleteCurrent:s})}}forEach(t,e){for(let{entity:s}of this)(!e||e(s))&&t(s)}find(t){for(let{entity:e}of this)if(t(e))return e}filter(t){let e=[];for(let{entity:s}of this)t(s)&&e.push(s);return e}map(t){let e=[];for(let{entity:s}of this)e.push(t(s));return e}getSharedMemory(){return this.list.getSharedMemory()}free(){this.list.free()}}h(E,"ALLOCATE_COUNT",M.ALLOCATE_COUNT);const $=0,Lt=1;class S extends Y{constructor(e,s){var t=(...ze)=>(super(...ze),h(this,"ships"),h(this,"moneyMemory"),this);s?(t(e,s),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new E(this.world,{initWithBlock:this.getAllocatedFromMemory(E.ALLOCATE_COUNT)})):(t(e,{size:2+E.ALLOCATE_COUNT,type:C.station}),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new E(this.world,{firstBlock:this.getAllocatedFromMemory(E.ALLOCATE_COUNT)}),this.width=20,this.height=20,this.shields=2,this.maxShields=2,this.timeToRegenerateShields=5),this.key="station"}get money(){return Atomics.load(this.moneyMemory,$)}set money(e){Atomics.store(this.moneyMemory,$,e)}get color(){return this.moneyMemory[Lt]}set color(e){this.moneyMemory[Lt]=e}addMoney(e){Atomics.add(this.moneyMemory,$,e)}subtractMoney(e){Atomics.sub(this.moneyMemory,$,e)}removeShip(e){this.dead||this.ships.delete(e)}die(){this.dead||(this.ships.forEach(e=>{e.die()}),this.ships.free(),super.die())}}class nt extends Y{constructor(e,s){var t=(...We)=>(super(...We),h(this,"station"),h(this,"uintMemory"),h(this,"velocityMemory"),this);"bufferPosition"in s?(t(e,s),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.station=this.world.getEntityByPointer(this.uintMemory[0])):(t(e,{size:5,type:C.ship}),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.width=10,this.height=5,this.speed=100,this.shields=1,this.maxShields=1,this.timeToRegenerateShields=1,this.station=s.station,this.uintMemory[0]=this.station.pointer)}get speed(){return this.velocityMemory[0]}set speed(e){this.velocityMemory[0]=e}get velocityX(){return this.velocityMemory[1]}set velocityX(e){this.velocityMemory[1]=e}get velocityY(){return this.velocityMemory[2]}set velocityY(e){this.velocityMemory[2]=e}get targetPointer(){return Atomics.load(this.uintMemory,1)}set targetPointer(e){Atomics.store(this.uintMemory,1,e)}get color(){var e;return((e=this.station)==null?void 0:e.color)??0}die(){var e;this.dead||((e=this.station)==null||e.removeShip(this),super.die())}}const ge=0,Rt=1,Dt=2,Ft=3,H=class H{constructor(t){h(this,"entities");h(this,"entityCache",new Map);h(this,"bounds");h(this,"heap");h(this,"memory");t?(this.heap=new It(t.heap),this.memory=new p(this.heap,t.world),this.entities=new E(this,{firstBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+Ft*this.memory.data.BYTES_PER_ELEMENT}})):(this.heap=new It({bufferSize:1024*100}),this.memory=this.heap.allocUI32(H.ALLOCATE_COUNT),this.entities=new E(this,{initWithBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+Ft*this.memory.data.BYTES_PER_ELEMENT}}));let e=this.memory;this.bounds={get width(){return e.data[Rt]},set width(s){e.data[Rt]=s},get height(){return e.data[Dt]},set height(s){e.data[Dt]=s}}}load(t){t.entities.forEach(e=>{let s;switch(e.type){case"station":s=new S(this);break;default:throw new Error(`Invalid entity type: ${e.type}`)}s.load(e),this.addEntity(s)}),t.bounds&&(this.bounds.width=t.bounds.width,this.bounds.height=t.bounds.height)}addEntity(t){this.entities.insert(t)}removeEntity(t){this.entities.delete(t)}getEntityByPointer(t){if(!t)return;let e=this.entityCache.get(t);if(e!=null&&e.dead&&(this.entityCache.delete(t),e=void 0),!e){let s=new p(this.heap,ht(t)),r=s.data[0];r===C.ship?e=new nt(this,s):r===C.station&&(e=new S(this,s)),e&&this.entityCache.set(t,e)}return e}update(t){try{this.garbageCollect()}catch{}}garbageCollect(){this.entities.forEach(t=>{t.dead&&this.entityCache.delete(t.pointer)})}growMemoryFromThread(t,e){t.forEach(s=>this.heap.addSharedBuffer(s))}getId(){return Atomics.add(this.memory.data,ge,1)}getSharedMemory(){return{heap:this.heap.getSharedMemory(),world:this.memory.getSharedMemory()}}};h(H,"ALLOCATE_COUNT",3+M.ALLOCATE_COUNT);let ot=H;const it=20;class Be{constructor(t={name:"System"}){h(this,"name");h(this,"currentDelta",0);h(this,"leftOverDelta",0);h(this,"deltaBetweenRuns");h(this,"firstRun",!0);h(this,"startedAt",0);h(this,"runTimes",[]);this.name=t.name??this.constructor.name,this.deltaBetweenRuns=t.deltaBetweenRuns??0}update(t){if(this.currentDelta+=t,!this.startedAt&&(this.currentDelta>=this.deltaBetweenRuns||this.firstRun)){let e=0;this.deltaBetweenRuns>0&&(e=this.currentDelta%this.deltaBetweenRuns),this.startedAt=performance.now();let s=this.run(this.currentDelta-e);return s instanceof Promise?s.then(()=>{this.finishRun()}):this.finishRun(),this.currentDelta=e,this.firstRun=!1,!0}else return!1}finishRun(){let t=performance.now()-this.startedAt;this.runTimes.push(t),this.runTimes.length>=it*2&&this.runTimes.splice(0,it),this.startedAt=0}destroy(){}getRuntimeStats(){let t=this.runTimes.slice(0,it),s=t.reduce((r,n)=>r+n,0)/t.length;return{min:Math.min(...t),avg:s,max:Math.max(...t),percent:s/(this.deltaBetweenRuns||16.66)}}}class k extends Be{constructor(e,s){super(s);h(this,"world");h(this,"worker");h(this,"runningResolve",null);h(this,"pendingUpdates",{memoryGrown:[]});this.world=e,this.worker=s.worker,this.worker.onmessage=n=>{var o;if(n.data.done){let f=n.data;this.world.growMemoryFromThread(f.memoryGrown,this),(o=this.runningResolve)==null||o.call(this),this.runningResolve=null}};const r=e.getSharedMemory();e.heap.addOnGrowBufferHandlers(n=>this.pendingUpdates.memoryGrown.push(n)),this.worker.postMessage({init:r})}run(e){return new Promise(s=>{this.runningResolve=s,this.worker.postMessage({elapsedTime:e,...this.pendingUpdates}),this.pendingUpdates={memoryGrown:[]}})}destroy(){this.worker.terminate()}}function we(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/velocity-system-BE7pTPnA.js",{name:i==null?void 0:i.name})}function Ae(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/update-health-timers-system-KObqiDfa.js",{name:i==null?void 0:i.name})}function Ee(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/spawn-ship-system-_8bPf2AU.js",{name:i==null?void 0:i.name})}function ke(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/collision-system-CpQtymN-.js",{name:i==null?void 0:i.name})}function Se(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/target-enemy-system-C6SIeDeP.js",{name:i==null?void 0:i.name})}function _e(i){return new Worker("/ecs-sharedarraybuffer-playground/assets/move-to-target-system-qfIIx_VJ.js",{name:i==null?void 0:i.name})}class Te extends ot{constructor(){super();h(this,"systems",[]);this.initSystems()}update(e){this.systems.forEach(s=>{s.update(e)}),super.update(e)}initSystems(){this.systems.push(new k(this,{name:"velocitySystem",worker:new we})),this.systems.push(new k(this,{name:"updateHealthTimersSystemWorker",worker:new Ae})),this.systems.push(new k(this,{name:"spawnShipSystem",worker:new Ee})),this.systems.push(new k(this,{name:"collisionSystem",worker:new ke})),this.systems.push(new k(this,{name:"targetEnemySystem",worker:new Se})),this.systems.push(new k(this,{name:"moveToTargetSystem",worker:new _e}))}growMemoryFromThread(e,s){super.growMemoryFromThread(e,s),this.systems.forEach(r=>{r===s||!(r instanceof k)||r.pendingUpdates.memoryGrown.push(...e)})}destroy(){this.systems.forEach(e=>e.destroy()),this.systems=[]}}const K=i=>(qt("data-v-d4f22489"),i=i(),Jt(),i),Me={class:"home"},Oe={class:"list"},Ne={style:{color:"red"}},Pe=K(()=>A("div",null,null,-1)),Ie=K(()=>A("p",null,null,-1)),xe=K(()=>A("br",null,null,-1)),ve=K(()=>A("div",{id:"phaser-container-simple"},null,-1)),Ce=Xt({__name:"SharedMemoryObjects",setup(i){let t=new Te;const e=B(0),s=B(0),r=B(0),n=B(0),o=B(0),f=B(0),u=B(0),d=B([]),g=B([]);let _;Ht(()=>{let O=0,b=[];const m=window.innerWidth/3*2,ft=window.innerHeight/3*2;let j=!1,Z;const L=[];_=new dt.Game({type:dt.AUTO,width:m,height:ft,parent:"phaser-container-simple",scene:{preload(){this.load.image("boid","boid.png"),this.load.image("station","station.png"),this.load.image("shield","shield3.png")},create(){var D;Z=this.add;let ut=performance.now();t.load(Yt({stations:8,shipsPerStation:100,width:m,height:ft}));let R=performance.now();e.value=R-ut;let q=t.entities.filter(l=>l instanceof S);d.value=q.map(l=>{let a="#"+l.color.toString(16);return a==="#ffffff"&&(a="#00000"),{color:l.color,displayColor:a,ships:l.ships.length}}),(D=this.input.keyboard)==null||D.on("keydown-SPACE",()=>{j=!j}),g.value=t.systems.map(l=>({name:l.name,min:0,avg:0,max:0}))},update(ut,R){if(j)return;let q=performance.now();t.entities.forEach(l=>{if(!l.getSprite){let a=Z.image(l.x,l.y,l.key);a.setScale(l.width/a.width,l.height/a.height),a.shieldImage=Z.image(l.x,l.y,"shield"),a.shieldImage.setScale(l.width/a.shieldImage.width*2,l.height/a.shieldImage.height*2),a.shieldImage.visible=l.shields>0,(l instanceof S||l instanceof nt)&&a.setTint(l.color),["x","y","angle"].forEach(c=>{Object.defineProperty(a,c==="angle"?"rotation":c,{get(){return l[c]??0}}),Object.defineProperty(a.shieldImage,c,{get(){return l[c]}})}),["_alphaBL","_alphaBR","_alphaTL","_alphaTR"].forEach(c=>{Object.defineProperty(a.shieldImage,c,{get:()=>l.shields>0?1:0})}),l.getSprite=()=>a,a.entity=l,L.push(a)}}),L.forEach(l=>{l.entity.dead&&(l.destroy(),l.shieldImage.destroy(),L.splice(L.indexOf(l),1))}),t.update(R/1e3);let D=performance.now();if(b.push(D-q),O+=R,O>1e3){s.value=b.reduce((a,c)=>Math.min(a,c),1e6),r.value=b.reduce((a,c)=>Math.max(a,c),0),n.value=b.reduce((a,c)=>a+c,0)/b.length,b=[],O=0,o.value=t.entities.filter(a=>a instanceof S).length,f.value=t.entities.filter(a=>a instanceof nt).length,u.value=t.entities.length;let l=t.entities.filter(a=>a instanceof S);d.value.forEach(a=>{let c=l.find(ct=>ct.color===a.color);c?a.ships=c.ships.length:a.ships>0&&(a.ships=0)}),g.value=t.systems.map(a=>({name:a.name,...a.getRuntimeStats()}))}}}})}),Kt(()=>{_&&(_.destroy(!0),_=null),t&&t.destroy()});function U(){t.entities.filter(b=>b instanceof S).forEach(b=>{b.addMoney(10)})}return(O,b)=>(P(),N("div",Me,[A("div",Oe,[A("div",Ne,"mainThread: "+y(s.value.toFixed(2))+" - "+y(r.value.toFixed(2))+" ("+y(n.value.toFixed(2))+" avg) ms",1),(P(!0),N(mt,null,yt(g.value,m=>(P(),N("div",{key:m.name},y(m.name)+": "+y(m.max.toFixed(2))+" ("+y(m.avg.toFixed(2))+" avg) ms",1))),128)),Pe,A("div",null,"Memory: "+y(jt(t).heap.prettyMemory()),1),Ie,A("div",null,"Entities: "+y(o.value)+" stations and "+y(f.value)+" ships ("+y(u.value)+")",1),(P(!0),N(mt,null,yt(d.value,m=>(P(),N("span",{class:"station-list",key:m.color,style:Zt({color:m.displayColor})},y("#"+m.color.toString(16))+": "+y(m.ships),5))),128)),xe,A("button",{onClick:U},"Add Ships")]),ve]))}}),De=Qt(Ce,[["__scopeId","data-v-d4f22489"]]);export{De as default};
