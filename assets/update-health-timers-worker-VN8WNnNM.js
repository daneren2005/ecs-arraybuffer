(function(){"use strict";function i(n){let e,o=t=>{console.warn("Updating system before sent")};self.onmessage=function(t){t.data.world?(e=t.data.world,o=n(e)):t.data.updateWorld?Object.keys(t.data.updateWorld).forEach(s=>{e[s]=t.data.updateWorld[s]}):t.data.delta&&(o(t.data.delta),self.postMessage({done:!0}))}}function r(n){switch(n){case"entity":return 1;case"position":return 2**1;case"velocity":return 2**2;case"health":return 2**3;case"controller":return 2**4;case"controlled":return 2**5;case"attack":return 2**6;default:return 0}}function c(n){let e=0;return n.forEach(o=>{e|=r(o)}),e}function l(n,e){let o=c(e),t=[],s=Atomics.load(n.idCounter,0);for(let a=0;a<=s;a++)(Atomics.load(n.components.entity.components,a)&o)===o&&Atomics.load(n.components.entity.dead,a)===0&&t.push(a);return t}function d(n){const e=n.components.health;return o=>{l(n,["health"]).forEach(t=>{Atomics.add(e.timeSinceTakenDamage,t,o*1e3),Atomics.load(e.shields,t)<Atomics.load(e.maxShields,t)&&(Atomics.add(e.timeSinceShieldRegeneration,t,o*1e3),Atomics.load(e.timeSinceShieldRegeneration,t)>Atomics.load(e.timeToRegenerateShields,t)&&(Atomics.add(e.shields,t,1),Atomics.store(e.timeSinceShieldRegeneration,t,0)))})}}i(d)})();
