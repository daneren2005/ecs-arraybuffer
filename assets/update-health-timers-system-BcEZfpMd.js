var Ft=Object.defineProperty;var Dt=(b,d,u)=>d in b?Ft(b,d,{enumerable:!0,configurable:!0,writable:!0,value:u}):b[d]=u;var h=(b,d,u)=>(Dt(b,typeof d!="symbol"?d+"":d,u),u);(function(){"use strict";const u=Math.pow(2,20),Y=Math.pow(2,12);function S(r,t=0){return P(Atomics.load(r,t))}function ct(r,t=0){return Atomics.load(r,t)}function G(r,t=0,e,i){Atomics.store(r,t,K(e,i))}function X(r,t=0,e){Atomics.store(r,t,e)}function dt(r,t,e,i){return Atomics.compareExchange(r,t,i,e)===i}function P(r){return{bufferPosition:r&4095,bufferByteOffset:r>>>12}}function K(r,t){return r+(t<<12)}class f{get bufferByteOffset(){return this.data.byteOffset}get pointer(){return K(this.bufferPosition,this.bufferByteOffset)}constructor(t,e){this.memory=t,"buffer"in e?(this.data=e.data,this.buffer=e.buffer,this.bufferPosition=this.memory.buffers.indexOf(e.buffer)):(this.bufferPosition=e.bufferPosition,this.buffer=t.buffers[e.bufferPosition],this.data=new Uint32Array(this.buffer.buf,e.bufferByteOffset))}getArray(t,e,i){return new t(this.data.buffer,this.data.byteOffset+e*t.BYTES_PER_ELEMENT,i)}getArrayMemory(t,e){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset+t*this.data.BYTES_PER_ELEMENT}}free(){this.buffer.free(this.data.byteOffset)}getSharedMemory(){return{bufferPosition:this.bufferPosition,bufferByteOffset:this.bufferByteOffset}}}const L=0,w=1;function H(r,t=0){for(;Atomics.compareExchange(r,t,L,w)!==L;)"WorkerGlobalScope"in self&&Atomics.wait(r,t,w)}function E(r,t=0){Atomics.compareExchange(r,t,w,L)!==w&&console.warn("We are unlocking when it was not locked!"),Atomics.notify(r,t)}const mt={5120:"i8",5121:"u8",5122:"i16",5123:"u16",5124:"i32",5125:"u32",5126:"f32"},yt={f32:Float32Array,f64:Float64Array},bt={i8:Int8Array,i16:Int16Array,i32:Int32Array},Bt={u8:Uint8Array,u8c:Uint8ClampedArray,u16:Uint16Array,u32:Uint32Array},At={i64:BigInt64Array,u64:BigUint64Array},Et={...yt,...bt,...Bt},gt=r=>{const t=mt[r];return t!==void 0?t:r};function pt(r,...t){const e=At[r];return new(e||Et[gt(r)])(...t)}const Z=0,W=1,j=2,q=3,J=4,B=5,Q=6,U=1,x=2,V=8*4,F=0,D=1,m=2*4;class R{constructor(t={}){if(this.buf=t.buf?t.buf:new ArrayBuffer(t.size||4096),this.start=t.start!=null?_(Math.max(t.start,0),4):0,this.u8=new Uint8Array(this.buf),this.u32=new Uint32Array(this.buf),this.state=new Uint32Array(this.buf,this.start,V/4),this.lock=new Int32Array(this.buf,this.start+this.state.byteLength-4,1),!t.skipInitialization){const e=t.align||8;if(e<8)throw new Error(`invalid alignment: ${e}, must be a pow2 and >= 8`);const i=this.initialTop(e),s=t.end!=null?Math.min(t.end,this.buf.byteLength):this.buf.byteLength;if(i>=s)throw new Error(`insufficient address range (0x${this.start.toString(16)} - 0x${s.toString(16)})`);this.align=e,this.doCompact=t.compact!==!1,this.doSplit=t.split!==!1,this.minSplit=t.minSplit||16,this.end=s,this.top=i,this._free=0,this._used=0}}stats(){const t=i=>{let s=0,o=0;for(;i;)if(s++,o+=this.blockSize(i),i=this.blockNext(i),i>this.end){console.error(`Trying to get stats for block past end of buffer: ${i} > ${this.end}`);break}return{count:s,size:o}},e=t(this._free);return{free:e,used:t(this._used),top:this.top,available:this.end-this.top+e.size,total:this.buf.byteLength}}callocAs(t,e,i=0){const s=this.mallocAs(t,e);return s&&s.fill(i),s}mallocAs(t,e){const i=this.malloc(e*Tt[t]);return i?pt(t,this.buf,i,e):void 0}calloc(t,e=0){const i=this.malloc(t);return i&&this.u8.fill(e,i,i+t),i}malloc(t){if(t<=0)return 0;H(this.lock);const e=_(t+m,this.align),i=this.end;let s=this.top,o=this._free,n=0;for(;o;){const l=this.blockSize(o),a=o+l>=s;if(a||l>=e){let c=this.mallocTop(o,n,l,e,a);return E(this.lock),c}n=o,o=this.blockNext(o)}if(o=s,s=o+e,s<=i){this.initBlock(o,e,this._used),this._used=o,this.top=s;let l=g(o);return E(this.lock),l}return E(this.lock),0}mallocTop(t,e,i,s,o){if(o&&t+s>this.end)return 0;if(e?this.unlinkBlock(e,t):this._free=this.blockNext(t),this.setBlockNext(t,this._used),this._used=t,o)this.top=t+this.setBlockSize(t,s);else if(this.doSplit){const n=i-s;n>=this.minSplit&&this.splitBlock(t,s,n)}return g(t)}realloc(t,e){if(e<=0)return 0;const i=M(t);let s=0,o=this._used,n=0;for(;o;){if(o===i){[s,n]=this.reallocBlock(o,e);break}o=this.blockNext(o)}return s&&s!==i&&this.u8.copyWithin(g(s),g(i),n),g(s)}reallocBlock(t,e){const i=this.blockSize(t),s=t+i,o=s>=this.top,n=_(e+m,this.align);if(n<=i){if(this.doSplit){const l=i-n;l>=this.minSplit?this.splitBlock(t,n,l):o&&(this.top=t+n)}else o&&(this.top=t+n);return[t,s]}return o&&t+n<this.end?(this.top=t+this.setBlockSize(t,n),[t,s]):(this.free(t),[M(this.malloc(e)),s])}reallocArray(t,e){if(t.buffer!==this.buf)return;const i=this.realloc(t.byteOffset,e*t.BYTES_PER_ELEMENT);return i?new t.constructor(this.buf,i,e):void 0}bytesFor(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return;e=t.byteOffset}else e=t;e=M(e);let i=this._used;for(;i;){if(i===e)return this.blockSize(e);i=this.blockNext(i)}}lengthOf(t){let e=this.bytesFor(t);if(e)return e/this.u32.BYTES_PER_ELEMENT}free(t){let e;if(typeof t!="number"){if(t.buffer!==this.buf)return!1;e=t.byteOffset}else e=t;H(this.lock),e=M(e);let i=this._used,s=0;for(;i;){if(i===e)return s?this.unlinkBlock(s,i):this._used=this.blockNext(i),this.insert(i),this.doCompact&&this.compact(),E(this.lock),!0;s=i,i=this.blockNext(i)}return E(this.lock),!1}freeAll(){this._free=0,this._used=0,this.top=this.initialTop()}release(){return delete this.u8,delete this.u32,delete this.state,delete this.buf,!0}get align(){return this.state[J]}set align(t){this.state[J]=t}get end(){return this.state[q]}set end(t){this.state[q]=t}get top(){return Atomics.load(this.state,j)}set top(t){Atomics.store(this.state,j,t)}get _free(){return Atomics.load(this.state,Z)}set _free(t){Atomics.store(this.state,Z,t)}get _used(){return Atomics.load(this.state,W)}set _used(t){Atomics.store(this.state,W,t)}get doCompact(){return!!(this.state[B]&U)}set doCompact(t){t?this.state[B]|=1<<U-1:this.state[B]&=~U}get doSplit(){return!!(this.state[B]&x)}set doSplit(t){t?this.state[B]|=1<<x-1:this.state[B]&=~x}get minSplit(){return this.state[Q]}set minSplit(t){if(t<=m)throw new Error(`illegal min split threshold: ${t}, require at least ${m+1}`);this.state[Q]=t}blockSize(t){return Atomics.load(this.u32,(t>>2)+F)}setBlockSize(t,e){return Atomics.store(this.u32,(t>>2)+F,e),e}blockNext(t){return Atomics.load(this.u32,(t>>2)+D)}setBlockNext(t,e){Atomics.store(this.u32,(t>>2)+D,e)}initBlock(t,e,i){const s=t>>>2;return Atomics.store(this.u32,s+F,e),Atomics.store(this.u32,s+D,i),t}unlinkBlock(t,e){this.setBlockNext(t,this.blockNext(e))}splitBlock(t,e,i){this.insert(this.initBlock(t+this.setBlockSize(t,e),i,0)),this.doCompact&&this.compact()}initialTop(t=this.align){return _(this.start+V+m,t)-m}compact(){let t=this._free,e=0,i=0,s,o=!1;for(;t;){for(s=t,i=this.blockNext(t);i&&s+this.blockSize(s)===i;)s=i,i=this.blockNext(i);if(s!==t){const n=s-t+this.blockSize(s);this.setBlockSize(t,n);const l=this.blockNext(s);let a=this.blockNext(t);for(;a&&a!==l;){const c=this.blockNext(a);this.setBlockNext(a,0),a=c}this.setBlockNext(t,l),o=!0}t+this.blockSize(t)>=this.top&&(this.top=t,e?this.unlinkBlock(e,t):this._free=this.blockNext(t)),e=t,t=this.blockNext(t)}return o}insert(t){let e=this._free,i=0;for(;e&&!(t<=e);)i=e,e=this.blockNext(e);i?this.setBlockNext(i,t):this._free=t,this.setBlockNext(t,e)}}const g=r=>r>0?r+m:0,M=r=>r>0?r-m:0,_=(r,t)=>(t--,r+t&~t),Tt={u8:1,u8c:1,i8:1,u16:2,i16:2,u32:4,i32:4,i64:8,u64:8,f32:4,f64:8},kt=["B","kB","MB","GB","TB","PB","EB","ZB","YB"],St=["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"],wt=["b","kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],Mt=["b","kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],tt=(r,t,e)=>{let i=r;return typeof t=="string"||Array.isArray(t)?i=r.toLocaleString(t,e):(t===!0||e!==void 0)&&(i=r.toLocaleString(void 0,e)),i};function _t(r,t){if(!Number.isFinite(r))throw new TypeError(`Expected a finite number, got ${typeof r}: ${r}`);t={bits:!1,binary:!1,space:!0,...t};const e=t.bits?t.binary?Mt:wt:t.binary?St:kt,i=t.space?" ":"";if(t.signed&&r===0)return` 0${i}${e[0]}`;const s=r<0,o=s?"-":t.signed?"+":"";s&&(r=-r);let n;if(t.minimumFractionDigits!==void 0&&(n={minimumFractionDigits:t.minimumFractionDigits}),t.maximumFractionDigits!==void 0&&(n={maximumFractionDigits:t.maximumFractionDigits,...n}),r<1){const k=tt(r,t.locale,n);return o+k+i+e[0]}const l=Math.min(Math.floor(t.binary?Math.log(r)/Math.log(1024):Math.log10(r)/3),e.length-1);r/=(t.binary?1024:1e3)**l,n||(r=r.toPrecision(3));const a=tt(Number(r),t.locale,n),c=e[l];return o+a+i+c}const Ot=8192;class et{constructor(t){if(this.onGrowBufferHandlers=[],t&&"buffers"in t)this.buffers=t.buffers.map(e=>new R({buf:e,skipInitialization:!0})),this.memory=new f(this,{bufferPosition:0,bufferByteOffset:40}),this.isClone=!0;else{const e=(t==null?void 0:t.bufferSize)??Ot;if(e>u)throw new Error(`Buffer size ${e} is greater than max ${u} that we can reference with pointers`);let i=this.createBuffer(e);this.buffers=[i];const s=i.callocAs("u32",1);if(s)this.memory=new f(this,{bufferPosition:0,bufferByteOffset:s.byteOffset});else throw new Error("Failed to initialize first byte from buffer");this.memory.data[0]=e,this.isClone=!1;for(let o=1;o<((t==null?void 0:t.initialBuffers)??1);o++)this.buffers.push(this.createBuffer(e))}}get bufferSize(){return this.memory.data[0]}addSharedBuffer(t){this.buffers.push(new R({buf:t,skipInitialization:!0}))}createBuffer(t){if(this.isClone)throw new Error("Creating new buffer from worker threads not currently supported");return new R({buf:new SharedArrayBuffer(t??this.bufferSize)})}allocUI32(t){for(let s=0;s<this.buffers.length;s++){const o=this.buffers[s],n=o.callocAs("u32",t);if(n)return new f(this,{data:n,buffer:o})}if(this.buffers.length>=Y)throw new Error(`Can't initialize a new buffer since it would have a position greater than the max of ${Y}`);const e=this.createBuffer();this.buffers.push(e),this.onGrowBufferHandlers.forEach(s=>s(e.buf));const i=e.callocAs("u32",t);if(i)return new f(this,{data:i,buffer:e});throw new Error(`Unable to allocate ${t} numbers even after adding a new buffer`)}get currentUsed(){return this.totalAllocated-this.buffers.reduce((t,e)=>t+e.stats().available,0)}get totalAllocated(){return this.buffers[0].buf.byteLength*this.buffers.length}prettyMemory(){return`${it(this.currentUsed)} / ${it(this.totalAllocated)}`}getSharedMemory(){return{buffers:this.buffers.map(t=>t.buf)}}}function it(r){return _t(r,{binary:!0,minimumFractionDigits:1,maximumFractionDigits:1})}const st=4,rt=1,p=2,$=class ${get length(){return Atomics.load(this.firstBlock.data,p)}get type(){return Atomics.load(this.uint16Array,0)}set type(t){Atomics.store(this.uint16Array,0,t)}get dataLength(){return Math.max(1,Atomics.load(this.uint16Array,1))}set dataLength(t){Atomics.store(this.uint16Array,1,t)}constructor(t,e){if(this.memory=t,e&&"firstBlock"in e)this.firstBlock=new f(t,e.firstBlock),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(p+1)*Uint32Array.BYTES_PER_ELEMENT,2);else{e&&e.initWithBlock?(this.firstBlock=new f(t,e.initWithBlock),console.log(`init block at ${this.firstBlock.data.byteOffset}`)):this.firstBlock=t.allocUI32(st),this.uint16Array=new Uint16Array(this.firstBlock.data.buffer,this.firstBlock.bufferByteOffset+(p+1)*Uint32Array.BYTES_PER_ELEMENT,2);const i=(e==null?void 0:e.type)??Uint32Array;i===Uint32Array?this.type=0:i===Int32Array?this.type=1:i===Float32Array&&(this.type=2),this.dataLength=(e==null?void 0:e.dataLength)??1}}insert(t){typeof t=="number"&&(t=[t]);let e=this.dataLength;if(t.length>e)throw new Error(`Can't insert ${t.length} array into shared list of ${e} dataLength`);let i=this.memory.allocUI32(rt+e),s=this.getDataBlock(i.data),o=i.pointer;for(let a=0;a<t.length;a++)s instanceof Int32Array||s instanceof Uint32Array?Atomics.store(s,a,t[a]):s[a]=t[a];let n,l=!1;for(;!l;)n=ct(this.firstBlock.data,1),l=dt(this.firstBlock.data,1,o,n);if(n){let{bufferPosition:a,bufferByteOffset:c}=P(n),k=new Uint32Array(this.memory.buffers[a].buf,c,1);X(k,0,o)}else X(this.firstBlock.data,0,o),console.log(`insert first block ${o} at ${this.firstBlock.data.byteOffset}`);Atomics.add(this.firstBlock.data,p,1)}deleteMatch(t){for(let{data:e,index:i,deleteCurrent:s}of this)if(t(e,i))return s(),!0;return!1}deleteIndex(t){return t>=this.length||t<0?!1:this.deleteMatch((e,i)=>i===t)}deleteValue(t){return typeof t=="number"?this.deleteMatch(e=>e[0]===t):this.deleteMatch(e=>{if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0})}*[Symbol.iterator](){let t=0,{bufferPosition:e,bufferByteOffset:i}=S(this.firstBlock.data,0);console.log(`checking first block: ${i} at ${this.firstBlock.data.byteOffset}`);let s=this.firstBlock.data,o=0,n=0;for(;i;){let l=this.memory.buffers[e],a=new Uint32Array(l.buf,i,2),c=this.getDataBlock(a),k=e,xt=i;({bufferPosition:e,bufferByteOffset:i}=S(a,0));let ut=!0;yield{data:c,index:t,deleteCurrent:()=>{G(s,0,e,i),i||G(this.firstBlock.data,1,o,n),l.free(a.byteOffset),Atomics.sub(this.firstBlock.data,p,1),ut=!1}},ut&&(s=a,o=k,n=xt,t++)}}forEach(t){for(let e of this)t(e.data)}getSharedMemory(){return{firstBlock:this.firstBlock.getSharedMemory()}}getDataBlock(t){const e=t.byteOffset+rt*t.BYTES_PER_ELEMENT;switch(this.type){case 1:return new Int32Array(t.buffer,e,this.dataLength);case 0:return new Uint32Array(t.buffer,e,this.dataLength);case 2:return new Float32Array(t.buffer,e,this.dataLength);default:throw new Error(`Unknown data block type ${this.type}`)}}free(){let{bufferPosition:t,bufferByteOffset:e}=S(this.firstBlock.data,0);for(;e;){let i=new f(this.memory,{bufferPosition:t,bufferByteOffset:e});({bufferPosition:t,bufferByteOffset:e}=S(i.data,0)),i.free()}this.firstBlock.free()}};$.ALLOCATE_COUNT=st;let A=$;const Nt=new ArrayBuffer(8);new BigUint64Array(Nt);const It=0,v=1,ot=2,I=class I{constructor(t,e){h(this,"world");h(this,"memory");h(this,"takenMemoryBytes",0);h(this,"_id");h(this,"positionMemory");h(this,"key","boid");h(this,"shieldMemory");h(this,"getSprite");this.world=t,"size"in e?(this.memory=t.heap.allocUI32(e.size+I.ALLOCATE_COUNT),this.memory.data[v]=t.getId(),this.memory.data[It]=e.type):e instanceof f?this.memory=e:this.memory=new f(t.heap,e),this._id=this.memory.data[v],this.takenMemoryBytes+=3*this.memory.data.BYTES_PER_ELEMENT,this.positionMemory=this.getArrayFromMemory(Float32Array,5),this.shieldMemory=this.getArrayFromMemory(Float32Array,5)}get id(){return this._id}get dead(){return this._id!==this.memory.data[v]||!!this.memory.data[ot]}set dead(t){this.memory.data[ot]=t?1:0}get x(){return this.positionMemory[0]}set x(t){this.positionMemory[0]=t}get y(){return this.positionMemory[1]}set y(t){this.positionMemory[1]=t}get width(){return this.positionMemory[2]}set width(t){this.positionMemory[2]=t}get height(){return this.positionMemory[3]}set height(t){this.positionMemory[3]=t}get angle(){return this.positionMemory[4]}set angle(t){this.positionMemory[4]=t}get shields(){return this.shieldMemory[0]}set shields(t){this.shieldMemory[0]=t}get maxShields(){return this.shieldMemory[1]}set maxShields(t){this.shieldMemory[1]=t}get timeToRegenerateShields(){return this.shieldMemory[2]}set timeToRegenerateShields(t){this.shieldMemory[2]=t}get timeSinceShieldRegeneration(){return this.shieldMemory[3]}set timeSinceShieldRegeneration(t){this.shieldMemory[3]=t}get timeSinceTakenDamage(){return this.shieldMemory[4]}set timeSinceTakenDamage(t){this.shieldMemory[4]=t}load(t){Object.keys(t).forEach(e=>{this[e]=t[e]})}die(){this.dead=!0,this.world.removeEntity(this),this.memory.free()}canTakeDamage(){return this.timeSinceTakenDamage>=.2&&!this.dead}takeDamage(t){this.canTakeDamage()&&(this.shields-=t,this.timeSinceTakenDamage=0,this.shields<0&&this.die())}getArrayFromMemory(t,e){let i=this.getAllocatedFromMemory(e);return new t(this.memory.data.buffer,i.bufferByteOffset,e)}getAllocatedFromMemory(t){let e=this.takenMemoryBytes;return this.takenMemoryBytes+=t*4,{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+e}}get pointer(){return this.memory.pointer}};h(I,"ALLOCATE_COUNT",13);let O=I;var T=(r=>(r[r.ship=1]="ship",r[r.station=2]="station",r))(T||{});class y{constructor(t,e){h(this,"world");h(this,"list");h(this,"entityCache",new Map);this.world=t,e?this.list=new A(t.heap,e):this.list=new A(t.heap)}get length(){return this.list.length}insert(t){this.list.insert(t.pointer),this.entityCache.set(t.pointer,t)}delete(t){return this.entityCache.delete(t.pointer),this.list.deleteValue(t.pointer)}*[Symbol.iterator](){let t=this.list[Symbol.iterator]();for(let{data:e,deleteCurrent:i}of t){let s=Atomics.load(e,0),o=this.world.getEntityByPointer(s);o&&(yield{entity:o,deleteCurrent:i})}}forEach(t,e){for(let{entity:i}of this)(!e||e(i))&&t(i)}find(t){for(let{entity:e}of this)if(t(e))return e}filter(t){let e=[];for(let{entity:i}of this)t(i)&&e.push(i);return e}map(t){let e=[];for(let{entity:i}of this)e.push(t(i));return e}getSharedMemory(){return this.list.getSharedMemory()}free(){this.list.free()}}h(y,"ALLOCATE_COUNT",A.ALLOCATE_COUNT);const N=0,nt=1;class ht extends O{constructor(e,i){var t=(...Rt)=>(super(...Rt),h(this,"ships"),h(this,"moneyMemory"),this);i?(t(e,i),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new y(this.world,{initWithBlock:this.getAllocatedFromMemory(y.ALLOCATE_COUNT)})):(t(e,{size:2+y.ALLOCATE_COUNT,type:T.station}),this.moneyMemory=this.getArrayFromMemory(Uint32Array,2),this.ships=new y(this.world,{firstBlock:this.getAllocatedFromMemory(y.ALLOCATE_COUNT)}),this.width=20,this.height=20,this.shields=2,this.maxShields=2,this.timeToRegenerateShields=5),this.key="station"}get money(){return Atomics.load(this.moneyMemory,N)}set money(e){Atomics.store(this.moneyMemory,N,e)}get color(){return this.moneyMemory[nt]}set color(e){this.moneyMemory[nt]=e}addMoney(e){Atomics.add(this.moneyMemory,N,e)}subtractMoney(e){Atomics.sub(this.moneyMemory,N,e)}removeShip(e){this.dead||this.ships.delete(e)}die(){this.dead||(this.ships.forEach(e=>{e.die()}),this.ships.free(),super.die())}}class Ct extends O{constructor(e,i){var t=(...vt)=>(super(...vt),h(this,"station"),h(this,"uintMemory"),h(this,"velocityMemory"),this);"bufferPosition"in i?(t(e,i),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.station=this.world.getEntityByPointer(this.uintMemory[0])):(t(e,{size:5,type:T.ship}),this.velocityMemory=this.getArrayFromMemory(Float32Array,3),this.uintMemory=this.getArrayFromMemory(Uint32Array,2),this.width=10,this.height=5,this.speed=100,this.shields=1,this.maxShields=1,this.timeToRegenerateShields=1,this.station=i.station,this.uintMemory[0]=this.station.pointer)}get speed(){return this.velocityMemory[0]}set speed(e){this.velocityMemory[0]=e}get velocityX(){return this.velocityMemory[1]}set velocityX(e){this.velocityMemory[1]=e}get velocityY(){return this.velocityMemory[2]}set velocityY(e){this.velocityMemory[2]=e}get targetPointer(){return Atomics.load(this.uintMemory,1)}set targetPointer(e){Atomics.store(this.uintMemory,1,e)}get color(){return this.station.color}die(){this.dead||(this.station.removeShip(this),super.die())}}const Pt=0,at=1,lt=2,ft=3,C=class C{constructor(t){h(this,"entities");h(this,"entityCache",new Map);h(this,"bounds");h(this,"heap");h(this,"memory");t?(this.heap=new et(t.heap),this.memory=new f(this.heap,t.world),this.entities=new y(this,{firstBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+ft*this.memory.data.BYTES_PER_ELEMENT}})):(this.heap=new et({bufferSize:u}),this.memory=this.heap.allocUI32(C.ALLOCATE_COUNT),this.entities=new y(this,{initWithBlock:{bufferPosition:this.memory.bufferPosition,bufferByteOffset:this.memory.data.byteOffset+ft*this.memory.data.BYTES_PER_ELEMENT}}));let e=this.memory;this.bounds={get width(){return e.data[at]},set width(i){e.data[at]=i},get height(){return e.data[lt]},set height(i){e.data[lt]=i}}}load(t){t.entities.forEach(e=>{let i;switch(e.type){case"station":i=new ht(this);break;default:throw new Error(`Invalid entity type: ${e.type}`)}i.load(e),this.addEntity(i)}),t.bounds&&(this.bounds.width=t.bounds.width,this.bounds.height=t.bounds.height)}addEntity(t){this.entities.insert(t)}removeEntity(t){this.entities.delete(t)}getEntityByPointer(t){if(!t)return;let e=this.entityCache.get(t);if(e!=null&&e.dead&&(this.entityCache.delete(t),e=void 0),!e){let i=new f(this.heap,P(t)),s=i.data[0];s===T.ship?e=new Ct(this,i):s===T.station&&(e=new ht(this,i)),e&&this.entityCache.set(t,e)}return e}update(t){this.garbageCollect()}garbageCollect(){this.entities.forEach(t=>{t.dead&&this.entityCache.delete(t.pointer)})}getId(){return Atomics.add(this.memory.data,Pt,1)}getSharedMemory(){return{heap:this.heap.getSharedMemory(),world:this.memory.getSharedMemory()}}};h(C,"ALLOCATE_COUNT",3+A.ALLOCATE_COUNT);let z=C;function Lt(r){let t,e;self.onmessage=function(i){i.data.init?(t=new z(i.data.init),e=r(t)):i.data.elapsedTime&&(e.run(i.data.elapsedTime),t.garbageCollect(),self.postMessage({done:!0}))}}class Ut{constructor(t){h(this,"world");this.world=t}run(t){this.world.entities.forEach(e=>{e.timeSinceTakenDamage+=t,e.shields<e.maxShields&&(e.timeSinceShieldRegeneration+=t,e.timeSinceShieldRegeneration>e.timeToRegenerateShields&&(e.shields++,e.timeSinceShieldRegeneration=0))})}}Lt(r=>new Ut(r))})();
