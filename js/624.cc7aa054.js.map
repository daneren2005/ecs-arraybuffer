{"version":3,"file":"js/624.cc7aa054.js","mappings":"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","sources":["webpack://ecs-arraybuffer/./src/multithreaded/systems/create-worker-system.ts","webpack://ecs-arraybuffer/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://ecs-arraybuffer/./node_modules/@timohausmann/quadtree-ts/src/Quadtree.ts","webpack://ecs-arraybuffer/./node_modules/@timohausmann/quadtree-ts/src/Rectangle.ts","webpack://ecs-arraybuffer/./src/multithreaded/components/get-type-bit.ts","webpack://ecs-arraybuffer/./src/multithreaded/components/get-type-bits.ts","webpack://ecs-arraybuffer/./src/multithreaded/components/get-entities.ts","webpack://ecs-arraybuffer/./src/math/euclidean-distance.ts","webpack://ecs-arraybuffer/./src/multithreaded/components/has-component.ts","webpack://ecs-arraybuffer/./src/multithreaded/systems/target-enemy-system.ts","webpack://ecs-arraybuffer/./src/multithreaded/systems/target-enemy-worker.ts"],"sourcesContent":["export default function createWorkerSystem(createSystem: (world: any) => ((delta: number) => void)) {\n\tlet world: any;\n\t// eslint-disable-next-line\n\tlet system = (delta: number) => { console.warn('Updating system before sent'); };\n\n\tself.onmessage = function(e) {\n\t\tif(e.data.world) {\n\t\t\tworld = e.data.world;\n\t\t\tsystem = createSystem(world);\n\t\t} else if(e.data.updateWorld) {\n\t\t\tObject.keys(e.data.updateWorld).forEach(key => {\n\t\t\t\tworld[key] = e.data.updateWorld[key];\n\t\t\t});\n\t\t} else if(e.data.delta) {\n\t\t\tsystem(e.data.delta);\n\n\t\t\tself.postMessage({\n\t\t\t\tdone: true\n\t\t\t});\n\t\t}\n\t};\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import type { NodeGeometry, Indexable } from './types';\nimport type { Rectangle } from './Rectangle';\nimport type { Circle } from './Circle';\nimport type { Line } from './Line';\n\n/**\n * Quadtree Constructor Properties\n */\nexport interface QuadtreeProps {\n\n    /**\n     * Width of the node.\n     */\n    width: number\n\n    /**\n     * Height of the node.\n     */\n    height: number\n\n    /**\n     * X Offset of the node.\n     * @defaultValue `0`\n     */\n    x?: number\n\n    /**\n     * Y Offset of the node.\n     * @defaultValue `0`\n     */\n    y?: number\n\n    /**\n     * Max objects this node can hold before it splits.\n     * @defaultValue `10`\n     */\n    maxObjects?: number\n\n    /**\n     * Total max nesting levels of the root Quadtree node.\n     * @defaultValue `4`\n     */\n    maxLevels?: number\n}\n\n/**\n * Class representing a Quadtree node.\n * \n * @example\n * ```typescript\n * const tree = new Quadtree({\n *   width: 100,\n *   height: 100,\n *   x: 0,           // optional, default:  0\n *   y: 0,           // optional, default:  0\n *   maxObjects: 10, // optional, default: 10\n *   maxLevels: 4,   // optional, default:  4\n * });\n * ```\n * \n * @example Typescript: If you like to be explicit, you optionally can pass in a generic type for objects to be stored in the Quadtree:\n * ```typescript\n * class GameEntity extends Rectangle {\n *   ...\n * }\n * const tree = new Quadtree<GameEntity>({\n *   width: 100,\n *   height: 100,\n * });\n * ```\n */\nexport class Quadtree<ObjectsType extends Rectangle|Circle|Line|Indexable> {\n\n    /**\n     * The numeric boundaries of this node.\n     * @readonly\n     */\n    bounds: NodeGeometry;\n\n    /**\n     * Max objects this node can hold before it splits.\n     * @defaultValue `10`\n     * @readonly\n     */\n    maxObjects: number;\n    \n    /**\n     * Total max nesting levels of the root Quadtree node.\n     * @defaultValue `4`\n     * @readonly\n     */\n    maxLevels: number;\n\n    /**\n     * The level of this node.\n     * @defaultValue `0`\n     * @readonly\n     */\n    level: number;\n\n    /**\n     * Array of objects in this node.\n     * @defaultValue `[]`\n     * @readonly\n     */\n    objects: ObjectsType[];\n\n    /**\n     * Subnodes of this node\n     * @defaultValue `[]`\n     * @readonly\n     */\n    nodes: Quadtree<ObjectsType>[];\n\n    /**\n     * Quadtree Constructor\n     * @param props - bounds and properties of the node\n     * @param level - depth level (internal use only, required for subnodes)\n     */\n    constructor(props:QuadtreeProps, level=0) {\n        \n        this.bounds = { \n            x: props.x || 0, \n            y: props.y || 0, \n            width: props.width, \n            height: props.height,\n        };\n        this.maxObjects = (typeof props.maxObjects === 'number') ? props.maxObjects : 10;\n        this.maxLevels  = (typeof props.maxLevels === 'number') ? props.maxLevels : 4;\n        this.level      = level;\n        \n        this.objects = [];\n        this.nodes   = [];\n    }\n    \n    /**\n     * Get the quadrant (subnode indexes) an object belongs to.\n     * \n     * @example Mostly for internal use but you can call it like so:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rectangle = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * const indexes = tree.getIndex(rectangle);\n     * console.log(indexes); // [1]\n     * ```\n     * \n     * @param obj - object to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right).\n     */\n    getIndex(obj:ObjectsType): number[] {\n        return obj.qtIndex(this.bounds);\n    }\n\n    /**\n     * Split the node into 4 subnodes.\n     * @internal\n     * \n     * @example Mostly for internal use! You should only call this yourself if you know what you are doing:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.split();\n     * console.log(tree); // now tree has four subnodes\n     * ```\n     */\n    split(): void {\n        \n        const level = this.level + 1,\n            width   = this.bounds.width/2,\n            height  = this.bounds.height/2,\n            x       = this.bounds.x,\n            y       = this.bounds.y;\n\n        const coords = [\n            { x: x + width, y: y },\n            { x: x,         y: y },\n            { x: x,         y: y + height },\n            { x: x + width, y: y + height },\n        ];\n\n        for(let i=0; i < 4; i++) {\n            this.nodes[i] = new Quadtree({\n                x: coords[i].x, \n                y: coords[i].y, \n                width,\n                height,\n                maxObjects: this.maxObjects,\n                maxLevels: this.maxLevels,\n            }, level);\n        }        \n    }\n\n\n    /**\n     * Insert an object into the node. If the node\n     * exceeds the capacity, it will split and add all\n     * objects to their corresponding subnodes.\n     * \n     * @example you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.insert(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     * \n     * @param obj - Object to be added.\n     */\n    insert(obj:ObjectsType): void {\n        \n        //if we have subnodes, call insert on matching subnodes\n        if(this.nodes.length) {\n            const indexes = this.getIndex(obj);\n    \n            for(let i=0; i<indexes.length; i++) {\n                this.nodes[indexes[i]].insert(obj);\n            }\n            return;\n        }\n    \n        //otherwise, store object here\n        this.objects.push(obj);\n\n        //maxObjects reached\n        if(this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n\n            //split if we don't already have subnodes\n            if(!this.nodes.length) {\n                this.split();\n            }\n            \n            //add all objects to their corresponding subnode\n            for(let i=0; i<this.objects.length; i++) {\n                const indexes = this.getIndex(this.objects[i]);\n                for(let k=0; k<indexes.length; k++) {\n                    this.nodes[indexes[k]].insert(this.objects[i]);\n                }\n            }\n\n            //clean up this node\n            this.objects = [];\n        }\n    }\n    \n    \n    /**\n     * Return all objects that could collide with the given geometry.\n     * \n     * @example Just like insert, you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript \n     * tree.retrieve(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.retrieve(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.retrieve(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     * \n     * @param obj - geometry to be checked\n     * @returns Array containing all detected objects.\n     */\n    retrieve(obj:ObjectsType): ObjectsType[] {\n        \n        const indexes = this.getIndex(obj);\n        let returnObjects = this.objects;\n            \n        //if we have subnodes, retrieve their objects\n        if(this.nodes.length) {\n            for(let i=0; i<indexes.length; i++) {\n                returnObjects = returnObjects.concat(this.nodes[indexes[i]].retrieve(obj));\n            }\n        }\n\n        //remove duplicates\n        returnObjects = returnObjects.filter(function(item, index) {\n            return returnObjects.indexOf(item) >= index;\n        });\n    \n        return returnObjects;\n    }\n\n\n    /**\n     * Clear the Quadtree.\n     * \n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10 }));\n     * tree.clear();\n     * console.log(tree); // tree.objects and tree.nodes are empty\n     * ```\n     */\n    clear(): void {\n        \n        this.objects = [];\n    \n        for(let i=0; i < this.nodes.length; i++) {\n            if(this.nodes.length) {\n                this.nodes[i].clear();\n            }\n        }\n\n        this.nodes = [];\n    }\n}","import type { NodeGeometry, Indexable } from './types';\n\n/**\n * Rectangle Geometry\n * @beta\n * \n * @remarks\n * This interface simply represents a rectangle geometry.\n */\nexport interface RectangleGeometry {\n\n    /**\n     * X start of the rectangle (top left).\n     */\n    x: number\n\n    /**\n     * Y start of the rectangle (top left).\n     */\n    y: number\n\n    /**\n     * Width of the rectangle.\n     */\n    width: number\n\n    /**\n     * Height of the rectangle.\n     */\n    height: number\n}\n\n/**\n * Rectangle Constructor Properties\n * @beta\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n */\nexport interface RectangleProps<CustomDataType = void> extends RectangleGeometry {\n\n    /**\n     * Custom data\n     */\n    data?: CustomDataType\n}\n\n/**\n * Class representing a Rectangle\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n * \n * @example Without custom data (JS/TS):\n * ```typescript\n * const rectangle = new Rectangle({ \n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n * });\n * ```\n * \n * @example With custom data (JS/TS):\n * ```javascript\n * const rectangle = new Rectangle({ \n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n *   data: { \n *     name: 'Jane', \n *     health: 100,\n *   },\n * });\n * ```\n * \n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n * \n * // Typescript will infer the type of the data property\n * const rectangle1 = new Rectangle({\n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n *   data: entity,\n * });\n * \n * // You can also pass in a generic type for the data property\n * const rectangle2 = new Rectangle<ObjectData>({ \n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n * });\n * rectangle2.data = entity;\n * ```\n * \n * @example With custom class extending Rectangle (implements {@link RectangleGeometry} (x, y, width, height)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Box extends Rectangle {\n *   \n *   constructor(props) {\n *     // call super to set x, y, width, height (and data, if given)\n *     super(props);\n *     this.content = props.content;\n *   }\n * }\n * \n * const box = new Box({\n *   content: 'Gravity Boots',\n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n * });\n * ```\n * \n * @example With custom class and mapping {@link RectangleGeometry}:\n * ```javascript\n * // no need to extend if you don't implement RectangleGeometry\n * class Box {\n *   \n *   constructor(content) {\n *     this.content = content;\n *     this.position = [10, 20];\n *     this.size = [30, 40];\n *   }\n *   \n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to RectangleGeometry\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   }\n * }\n * \n * const box = new Box('Gravity Boots');\n * ```\n * \n * @example With custom object that implements {@link RectangleGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane', \n *   health: 100,\n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 30,\n *   qtIndex: Rectangle.prototype.qtIndex,\n * });\n * ```\n * \n * @example With custom object and mapping {@link RectangleGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible. \n * // Using this technique, each object would have it's own qtIndex method. \n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane', \n *   health: 100,\n *   position: [10, 20], \n *   size: [30, 40], \n *   qtIndex: function(node) {\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   },\n * });\n * ```\n */\nexport class Rectangle<CustomDataType = void> implements RectangleGeometry, Indexable {\n\n    /**\n     * X start of the rectangle (top left).\n     */\n    x: number;\n\n    /**\n     * Y start of the rectangle (top left).\n     */\n    y: number;\n\n    /**\n     * Width of the rectangle.\n     */\n    width: number;\n\n    /**\n     * Height of the rectangle.\n     */\n    height: number;\n\n    /**\n     * Custom data.\n     */\n    data?: CustomDataType;\n\n    constructor(props:RectangleProps<CustomDataType>) {\n        \n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.data = props.data;\n    }\n    \n    /**\n     * Determine which quadrant this rectangle belongs to.\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node:NodeGeometry): number[] {\n        \n        const indexes:number[] = [],\n            boundsCenterX   = node.x + (node.width/2),\n            boundsCenterY   = node.y + (node.height/2);\n\n        const startIsNorth  = this.y < boundsCenterY,\n            startIsWest     = this.x < boundsCenterX,\n            endIsEast       = this.x + this.width > boundsCenterX,\n            endIsSouth      = this.y + this.height > boundsCenterY;\n\n        //top-right quad\n        if(startIsNorth && endIsEast) {\n            indexes.push(0);\n        }\n        \n        //top-left quad\n        if(startIsWest && startIsNorth) {\n            indexes.push(1);\n        }\n\n        //bottom-left quad\n        if(startIsWest && endIsSouth) {\n            indexes.push(2);\n        }\n\n        //bottom-right quad\n        if(endIsEast && endIsSouth) {\n            indexes.push(3);\n        }\n     \n        return indexes;\n    }\n}","export default function getTypeBit(type: string): number {\n\tswitch(type) {\n\t\tcase 'entity':\n\t\t\treturn 1;\n\t\tcase 'position':\n\t\t\treturn 2 ** 1;\n\t\tcase 'velocity':\n\t\t\treturn 2 ** 2;\n\t\tcase 'health':\n\t\t\treturn 2 ** 3;\n\t\tcase 'controller':\n\t\t\treturn 2 ** 4;\n\t\tcase 'controlled':\n\t\t\treturn 2 ** 5;\n\t\tcase 'attack':\n\t\t\treturn 2 ** 6;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}","import getTypeBit from './get-type-bit';\n\nexport default function getTypeBits(types: Array<string>): number {\n\tlet typeBits = 0;\n\ttypes.forEach(type => {\n\t\ttypeBits |= getTypeBit(type);\n\t});\n\n\treturn typeBits;\n}","import WorldConfig from '../entities/world-config';\nimport getTypeBits from './get-type-bits';\n\n// NOTE: All of these have to live in a single file in order to make sure that inlining them into the web worker doesn't try to reference dynamic __WEBPACK_IMPORT\n// Components and WorldConfig can live separately since they are just type hints that get stripped from the js code anyways\nexport function getEntitiesWithComponents(world: WorldConfig, types: Array<string>) {\n\tlet typeBits = getTypeBits(types);\n\n\tlet eids = [];\n\tlet currentCounter = Atomics.load(world.idCounter, 0);\n\tfor(let eid = 0; eid <= currentCounter; eid++) {\n\t\tif((Atomics.load(world.components.entity.components, eid) & typeBits) === typeBits && Atomics.load(world.components.entity.dead, eid) === 0) {\n\t\t\teids.push(eid);\n\t\t}\n\t}\n\n\treturn eids;\n}\n\nexport function getAllEntitiesWithComponents(world: WorldConfig, types: Array<string>) {\n\tlet typeBits = getTypeBits(types);\n\n\tlet eids = [];\n\tlet currentCounter = Atomics.load(world.idCounter, 0);\n\tfor(let eid = 0; eid <= currentCounter; eid++) {\n\t\tif((Atomics.load(world.components.entity.components, eid) & typeBits) === typeBits) {\n\t\t\teids.push(eid);\n\t\t}\n\t}\n\n\treturn eids;\n}","export default function euclideanDistance(x1: number, y1: number, x2: number, y2: number): number {\n\treturn (x1 - x2) ** 2 + (y1 - y2) ** 2;\n}","import Components from './components';\nimport getTypeBit from './get-type-bit';\n\nexport default function hasComponent(components: Components, eid: number, type: string) {\n\treturn (Atomics.load(components.entity.components, eid) & getTypeBit(type)) > 0;\n}","import { Quadtree, Rectangle } from '@timohausmann/quadtree-ts/src/index.esm';\nimport { getEntitiesWithComponents } from '../components/get-entities';\nimport WorldConfig from '../entities/world-config';\nimport euclideanDistance from '@/math/euclidean-distance';\nimport hasComponent from '../components/has-component';\n\nexport default function targetEnemySystem(world: WorldConfig) {\n\tconst position = world.components.position;\n\tconst controlled = world.components.controlled;\n\tconst controller = world.components.controller;\n\tconst attack = world.components.attack;\n\n\treturn () => {\n\t\t// Create and populate quadtree\n\t\tlet quadtree = new Quadtree({\n\t\t\twidth: world.bounds.width * 1_000,\n\t\t\theight: world.bounds.height * 1_000\n\t\t});\n\t\tgetEntitiesWithComponents(world, ['position', 'health']).forEach(eid => {\n\t\t\tlet data = {\n\t\t\t\tx: Atomics.load(position.x, eid),\n\t\t\t\ty: Atomics.load(position.y, eid),\n\t\t\t\twidth: Atomics.load(position.width, eid),\n\t\t\t\theight: Atomics.load(position.height, eid)\n\t\t\t};\n\n\t\t\tquadtree.insert(new Rectangle({\n\t\t\t\t...data,\n\t\t\t\tdata: {\n\t\t\t\t\teid,\n\t\t\t\t\t...data\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\n\t\t// TODO: Don't wait a full 200ms to process ships that are just sitting there waiting\n\t\tgetEntitiesWithComponents(world, ['velocity', 'attack']).forEach(eid => {\n\t\t\tlet shipColor = Atomics.load(controller.color, Atomics.load(controlled.owner, eid));\n\t\t\tlet x = Atomics.load(position.x, eid);\n\t\t\tlet y = Atomics.load(position.y, eid);\n\t\t\tlet width = Atomics.load(position.width, eid);\n\t\t\tlet height = Atomics.load(position.height, eid);\n\n\t\t\t// Try to find the nearest enemy\n\t\t\tlet rect = {\n\t\t\t\tx: x - 50 * 1_000,\n\t\t\t\ty: y - 50 * 1_000,\n\t\t\t\twidth: width + 100 * 1_000,\n\t\t\t\theight: height + 100 * 1_000\n\t\t\t};\n\t\t\tlet enemies = getEnemiesInRange(quadtree, rect, eid, shipColor);\n\t\t\tif(enemies.length === 0) {\n\t\t\t\trect.x -= 100 * 1_000;\n\t\t\t\trect.y -= 100 * 1_000;\n\t\t\t\trect.width += 200 * 1_000;\n\t\t\t\trect.height += 200 * 1_000;\n\t\t\t\tenemies = getEnemiesInRange(quadtree, rect, eid, shipColor);\n\t\t\t}\n\t\n\t\t\tenemies.sort((a, b) => {\n\t\t\t\treturn euclideanDistance(a.x, a.y, x, y) - euclideanDistance(b.x, b.y, x, y);\n\t\t\t});\n\t\t\tlet enemy = enemies[0] ?? null;\n\n\t\t\t// If no enemies that quadtree could easily find, just head for the nearest station\n\t\t\tif(!enemy) {\n\t\t\t\tlet stations = getEntitiesWithComponents(world, ['controller']).filter(stationEid => Atomics.load(controller.color, stationEid) !== shipColor && !world.components.entity.dead[stationEid]);\n\t\t\t\tstations.sort((a, b) => {\n\t\t\t\t\treturn euclideanDistance(Atomics.load(position.x, a), Atomics.load(position.y, a), x, y) - euclideanDistance(Atomics.load(position.x, b), Atomics.load(position.y, b), x, y);\n\t\t\t\t});\n\n\t\t\t\tif(stations.length) {\n\t\t\t\t\tenemy = {\n\t\t\t\t\t\teid: stations[0],\n\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\theight: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(enemy) {\n\t\t\t\tAtomics.store(attack.target, eid, enemy.eid);\n\t\t\t} else {\n\t\t\t\tAtomics.store(attack.target, eid, 0);\n\t\t\t}\n\t\t});\n\t};\n\n\tfunction getEnemiesInRange(quadtree: any, range: { x: number, y: number, width: number, height: number }, eid: number, shipColor: number) : Array<QuadtreeData> {\n\t\tlet entitiesInRange = quadtree.retrieve(new Rectangle(range)).map((result: any) => result.data) as Array<QuadtreeData>;\n\t\tentitiesInRange = entitiesInRange.filter(data => data.eid !== eid);\n\t\treturn entitiesInRange.filter(data => {\n\t\t\t// Ship\n\t\t\tif(hasComponent(world.components, data.eid, 'controlled')) {\n\t\t\t\tlet stationEid = Atomics.load(controlled.owner, data.eid);\n\t\t\t\treturn Atomics.load(controller.color, stationEid) !== shipColor;\n\t\t\t}\n\t\t\t// Station\n\t\t\telse if(hasComponent(world.components, data.eid, 'controller')) {\n\t\t\t\treturn Atomics.load(controller.color, data.eid) !== shipColor;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n\n\tinterface QuadtreeData {\n\t\teid: number;\n\t\tx: number;\n\t\ty: number;\n\t\twidth: number;\n\t\theight: number\n\t}\n}","import createWorkerSystem from './create-worker-system';\nimport targetEnemySystem from './target-enemy-system';\n\ncreateWorkerSystem(targetEnemySystem);"],"names":["createWorkerSystem","createSystem","world","system","delta","console","warn","self","onmessage","e","data","updateWorld","Object","keys","forEach","key","postMessage","done","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","Quadtree","constructor","props","level","this","bounds","x","y","width","height","maxObjects","maxLevels","objects","nodes","getIndex","qtIndex","split","coords","i","insert","length","indexes","push","k","retrieve","returnObjects","concat","filter","item","index","indexOf","clear","Rectangle","node","boundsCenterX","boundsCenterY","startIsNorth","startIsWest","endIsEast","endIsSouth","getTypeBit","type","getTypeBits","types","typeBits","getEntitiesWithComponents","eids","currentCounter","Atomics","load","idCounter","eid","components","entity","dead","euclideanDistance","x1","y1","x2","y2","hasComponent","targetEnemySystem","position","controlled","controller","attack","quadtree","shipColor","color","owner","rect","enemies","getEnemiesInRange","sort","a","b","enemy","stations","stationEid","store","target","range","entitiesInRange","map","result"],"sourceRoot":""}